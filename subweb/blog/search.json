[{"title":"【教程】Windows系统下VScode配置LaTeX环境","date":"2025-12-07T10:13:20.000Z","url":"/subweb/blog/2025/12/07/0019.Windows%E7%B3%BB%E7%BB%9FVScode%E9%85%8D%E7%BD%AELaTeX%E7%8E%AF%E5%A2%83/","tags":[["教程","/subweb/blog/tags/%E6%95%99%E7%A8%8B/"],["VScode","/subweb/blog/tags/VScode/"],["LaTeX","/subweb/blog/tags/LaTeX/"],["环境配置","/subweb/blog/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"]],"categories":[["教程","/subweb/blog/categories/%E6%95%99%E7%A8%8B/"]],"content":"前言LaTeX作为一款强大的文字排版工具，在学术领域等的重要性不言而喻，那么如何在VScode环境中搭建LaTeX编辑器呢？本文将详细概述。 一、下载TexLive由于MiKTex标准版安装程序只安装基本的东西，其它任何需要的东西可以动态安装；而TexLive则是完全安装，由于本人不希望在实际使用时被打断安装需要的包，因此选择TexLive进行安装。 你可以进入TexLive的官网下载，也可以直接此链接进入iso镜像下载页面，点击如下图所示位置进入最近的镜像站。 这里我进入了北京外国语大学的镜像站。如果加载缓慢，也可选择第二行的 mirror list 进入镜像列表，自行选择镜像源。进入镜像后选择最新版本的iso文件，如下图所示。（如果下载缓慢也可以自行更换镜像源，国内一般清华大学的比较快，由实际网络情况决定，点这里直接进入清华大学镜像） 二、安装TexLive下载好后，找到下载好的iso镜像，双击（使用资源管理器）打开，找到install-tl-windows.bat，右键选择以管理员身份允许。 运行后会出现下图界面，不必管它，过一会自动消失。 出现如下界面后，正式开始安装，第一行Installation root是安装路径，自行选择，最后一行TeXwork是TexLive自带的编辑工具，据说不好用，同时本文使用VScode作为编辑器，故取消勾选，不安装TeXworks。如果你需要更加个性化的安装，请点击左下角的Advanced。 如下所示为各个选项的功能，不懂的功能一定不要乱改，一般改一下安装路径就好了。点击右下角的安装会自动开始安装。 我当前安装的版本要安装个4810组件，要安装很久。安装好后点击右下角的关闭即可。 可以通过按下win+R后输入cmd，打开命令行，输入命令xelatex -v来检查是否安装正常： 如果如上图输出了版本信息，则说明安装正常。 三、VScode安装LaTeX支持插件LaTeX Workshop点击拓展图标，打开拓展；搜索框输入 latex workshop ，选择第一个LaTeX Workshop插件，点击 安装 ，等待安装完成。 四、配置LaTeX设置点击左下角小齿轮图标篇，再点击设置进入设置界面。 点击设置页右上角的 打开设置(json) ，打开设置的json文档。 正常情况下该文档应该为如下情况： 如果你之前修改过设置，或添加过远程等内容，花括号中间应该有一些配置内容。例如我之前有用过vscode远程开发，我这边的setting.json的内容为： 如果你是第一种情况，那很简单了，你只需要直接复制下面给出的配置内容粘贴到文档的花括号中就行了，注意外侧的两个花括号仍然独占一行，保证易读性。 如果你是第二种情况，你需要再原有的配置最后一行（不包含花括号）上加上逗号（英文的逗号）,，然后换行后粘贴上述内容。这里我最终的文档是这样的。 完成后Ctrl+S保存文档。 这里再配置文件中直接插入配置是更快的方法，同样也可以使用GUI操作，这里不再赘述。 配置文件解读如果你感兴趣，或需要更加个性化的自定义配置，可以看本篇，如果你不需要，可以直接跳过。 1.自动保存：latex-workshop.latex.autoBuild.run 设置什么时候自动进行代码的编译，值可以是以下三个： onFileChange：在检测任何依赖项中的文件更改(甚至被其他应用程序修改)时构建项目，即当检测到代码被更改时就自动编译tex文件； onSave : 当代码被保存时自动编译文件； never: 从不自动编译，即需编写者手动编译文档 这边我选择never，因为本人有三步一保存的习惯，一篇几千字的文章能保存几百次，为了避免造成卡顿，选择了never。如果你希望你的代码时刻再旁边展示编译结果，可以选择其它两种 2.上下文LaTeX菜单 启用上下文LaTeX菜单。默认为false，因为它可以通过新的 LaTeX 标记使用（新的 LaTeX 标记能够编译文档，将在下文提及）。只需将此变量设置为true即可恢复菜单。即此命令设置是否将编译文档的选项出现在鼠标右键的菜单中。 3.从宏包自动提取命令和环境 设置为true，则该拓展能够从使用的宏包中自动提取命令和环境，从而补全正在编写的代码。 4.是否弹出Error 文档编译时是否弹出Error信息，即使关闭也可以从终端看到，程序员的话是要学会无视警告和错误的。 5.是否弹出Warning 同上 6.编译命令 定义下文recipes编译链中使用的编译命令。 name：命令的标签，可被下文recipes引用 command：该扩展的编译方式 args：命令的参数列表 前三个xelatex，pdflatex，latexmk中，如果将参数列表中的%DOC%改为%DOCFILE%则可以使编译器支持中文路径，但不建议这么做，因为其它包仍然要访问文档的路径，可能会因为中文路径报错。 这里biber是一种更加现代的参考文献工具，bibtex是传统的工具。 7.recipes编译链 此串代码是对编译链进行定义，其中name是标签，也就是出现在工具栏中的链名称；tool是name标签所对应的编译顺序，其内部编译命令来自上文latex-workshop.latex.recipes中内容。 PDFLaTeX 编译模式与 XeLaTeX 区别如下： PDFLaTeX 使用的是TeX的标准字体，所以生成PDF时，会将所有的非 TeX 标准字体进行替换，其生成的 PDF 文件默认嵌入所有字体；而使用 XeLaTeX 编译，如果说论文中有很多图片或者其他元素没有嵌入字体的话，生成的 PDF 文件也会有些字体没有嵌入。 XeLaTeX 对应的 XeTeX 对字体的支持更好，允许用户使用操作系统字体来代替 TeX 的标准字体，而且对非拉丁字体的支持更好。 PDFLaTeX 进行编译的速度比 XeLaTeX 速度快。 引用自 蛐蛐蛐先生的博客 。 编译链是为了更方便的添加其它内容，如biber，如果需要插入参考文献，则需要多次执行编译，而编译链很好的解决了这个问题。 8.自动清理 编译过程中会生成很多中间文件，如果无特殊需要，可以直接删除，该配置就是自动帮我们做了这件事。 9.是否自动清理 这条命令是设置什么时候对上文设置的辅助文件进行清除。 onBuilt : 无论是否编译成功，都选择清除辅助文件； onFailed : 当编译失败时，清除辅助文件； never : 无论何时，都不清除辅助文件。 由于 tex 文档编译有时需要用到辅助文件，比如编译目录和编译参考文献时，如果使用onBuilt命令，则会导致编译不出完整结果甚至编译失败； 而有时候将 tex 文件修改后进行编译时，可能会导致 pdf 文件没有正常更新的情况，这个时候可能就是由于辅助文件没有进行及时更新的缘故，需要清除辅助文件了，而never命令做不到这一点。 故使用onFailed可以同时解决这两个问题 10.选择的默认编译链 该命令的作用为设置 vscode 编译 tex 文档时的默认编译链。 first : 使用latex-workshop.latex.recipes中的第一条编译链； lastUsed : 使用最近一次编译所用的编译链。 11.反向同步 用于反向同步（从编译出的 pdf 文件指定位置跳转到 tex 文件中相应代码所在位置）的内部查看器的快捷键绑定。 ctrl-click ： 为默认选项，使用Ctrl&#x2F;cmd+鼠标左键单击 double-click : 使用鼠标左键双击 这里和overleaf保持同步，方便切换。 五、测试Tex文件编译重启VScode就算是配置完成了，为了测试配置是否完整，建议先创建一个测试项目进行测试，如果能正确编译则说明配置完毕。 1.打开文件夹点击菜单栏的文件，打开文件夹，创建一个测试文件夹（或工作集）。 2.写一个测试项目这里我选择创建一个LatexTest子文件夹，在其中创建测试项目，这里给出我的测试项目如下。 ①main.tex ②test.bib 3.编译项目有多种方式进行编译，选择其中一种即可。 方法一：到LaTeX插件处编译 因为测试文件使用的是较新的bibLatex作为插入参考文献的工具，故使用biber的编译链，也可以选择其它编译链进行编译。 方法二：在tex文件处直接右键编译 但这种方式会选择默认编译链，会导致未经过biber编译链编译，参考文献处为上标的参考文献号。 正确编译好后就可以在文件页看到pdf文件了，正确编译的pdf文件如下： 请自行检查编译好后的pdf文档，按大标题进行检查。 左下方这里会在编译时显示步骤 如图就是在进行编译链的第一步，编译成功后会变为对号。 4.测试同步不论是代码还是pdf文档都是可以直接同步到对侧的，代码处可以右键，选择从光标同步。 可以看到立刻就同步到pdf中的对应位置了。 pdf中也可以用之前设置的同步方式同步到代码的对应位置。 参考本篇内容为参考Ali-loner在知乎的教程，实际操作所写，与原文步骤基本相同，但具体内容不同，对其内容进行了修改以与时俱进。"},{"title":"【技术分享】使用ADB安装拆分安装包或补充安装包（以Tailscale为例）","date":"2024-04-17T17:27:16.000Z","url":"/subweb/blog/2024/04/18/0018.%E4%BD%BF%E7%94%A8adb%E5%AE%89%E8%A3%85%E6%8B%86%E5%88%86%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%88%E4%BB%A5Tailscale%E4%B8%BA%E4%BE%8B%EF%BC%89/","tags":[["Android","/subweb/blog/tags/Android/"],["adb","/subweb/blog/tags/adb/"]],"categories":[["技术分享","/subweb/blog/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"APK拆分技术APK拆分技术是一种优化Android应用部署和分发的方法，它允许开发者将一个大的单一APK文件分割成多个独立的功能模块或配置相关的APK文件。这种技术有助于降低应用体积、提升下载效率、节省存储空间，并且可以根据设备的具体特性按需下载相应的模块。 安装方法Tailscale在play商店安装后可提取出以下5个文件，必须都安装应用才能正常使用（语言包可以只安装一个）。 需要安装此软件可以通过系统的包管理程序进行安装。 首先要将这些安装包发送到手机上，这里选择发送到系统临时文件夹，可在系统清理时自动删除。通过以下命令将文件推送到手机中，记得更换对应的路径，实例中各种安装包的安装路径为：D:\\Tailscale-apk-installer请替换为实际需要的路径。 执行这些命令如图所示。 如果没用报错，那么这些安装包已经发送到手机中了，接下来需要使用adb创建一个包管理安装进程，需要先进入shell模式，可输入下面的命令进入shell模式。 先创建一个包管理（pm）进程： 此时，会创建一个安装进程，返回结果如图所示。 返回结果中有一串数字（session id）后面有用，这是后续控制该安装程序的id。将后续命令的session都换成你实际上返回的。然后分别执行下面命令，写入全部安装包。 执行后全部返回内容如图所示。 然后提交安装即可。 执行完成后完成安装。可能会在手机上弹出是否安装的提示，点击同意安装。这样就完成安装了。 补充安装包方法如果已经通过adb install安装了主包该怎么办呢？只安装主包通常会闪退，可通过下面方法安装剩余分包。 首先我们需要知道安装软件的包名，如talscale的包名为 com.tailscale.ipn。 首先仍需要将安装包文件发送到手机。（此处省略） 然后对该包进行安装，如下命令创建pm进程，同样获取了一个session 然后输入下面命令将安装包写入此包。 同样提交执行安装即可。 现在就可以正常使用app了。"},{"title":"【学习笔记】Maven入门、原理与实战","date":"2024-04-17T17:27:16.000Z","url":"/subweb/blog/2024/04/18/0017.maven/","tags":[["计算机","/subweb/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"],["学习","/subweb/blog/tags/%E5%AD%A6%E4%B9%A0/"],["maven","/subweb/blog/tags/maven/"],["java","/subweb/blog/tags/java/"],["javaweb","/subweb/blog/tags/javaweb/"],["笔记","/subweb/blog/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["程序猿笔记","/subweb/blog/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%AC%94%E8%AE%B0/"]],"content":"第一只锦囊 学完 JavaWeb 后打开第一章 Maven 概述第一节 Why？为什么要学习 Maven？1、Maven 作为依赖管理工具①jar 包的规模随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。 比如下面的例子，我们只用到 SpringBoot、SpringCloud 框架中的三个功能： Nacos 服务注册发现 Web 框架环境 图模板技术 Thymeleaf 最终却导入了 106 个 jar 包： org.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compilecom.netflix.ribbon: ribbon:jar:2.3.0:compileorg.springframework.boot:spring-boot-starter-thymeleaf:jar:2.3.6.RELEASE:compilecommons-configuration:commons-configuration:jar:1.8:compileorg.apache.logging.log4j:log4j-api:jar:2.13.3:compileorg.springframework:spring-beans:jar:5.2.11.RELEASE:compileorg.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.2.6.RELEASE:compileorg.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.39:compilecom.alibaba.cloud:spring-cloud-alibaba-commons:jar:2.2.6.RELEASE:compileorg.bouncycastle:bcprov-jdk15on:jar:1.64:compileorg.springframework.security:spring-security-crypto:jar:5.3.5.RELEASE:compileorg.apache.httpcomponents:httpasyncclient:jar:4.1.4:compilecom.google.j2objc:j2objc-annotations:jar:1.3:compilecom.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compileio.reactivex:rxjava:jar:1.3.8:compilech.qos.logback:logback-classic:jar:1.2.3:compileorg.springframework:spring-web:jar:5.2.11.RELEASE:compileio.reactivex:rxnetty-servo:jar:0.4.9:runtimeorg.springframework:spring-core:jar:5.2.11.RELEASE:compileio.github.openfeign.form:feign-form-spring:jar:3.8.0:compileio.github.openfeign.form:feign-form:jar:3.8.0:compilecom.netflix.ribbon:ribbon-loadbalancer:jar:2.3.0:compileorg.apache.httpcomponents:httpcore:jar:4.4.13:compileorg.thymeleaf.extras:thymeleaf-extras-java8time:jar:3.0.4.RELEASE:compileorg.slf4j:jul-to-slf4j:jar:1.7.30:compilecom.atguigu.demo:demo09-base-entity:jar:1.0-SNAPSHOT:compileorg.yaml:snakeyaml:jar:1.26:compileorg.springframework.boot:spring-boot-starter-logging:jar:2.3.6.RELEASE:compileio.reactivex:rxnetty-contexts:jar:0.4.9:runtimeorg.apache.httpcomponents:httpclient:jar:4.5.13:compileio.github.openfeign:feign-core:jar:10.10.1:compileorg.springframework.boot:spring-boot-starter-aop:jar:2.3.6.RELEASE:compileorg.hdrhistogram:HdrHistogram:jar:2.1.9:compileorg.springframework:spring-context:jar:5.2.11.RELEASE:compilecommons-lang:commons-lang:jar:2.6:compileio.prometheus:simpleclient:jar:0.5.0:compilech.qos.logback:logback-core:jar:1.2.3:compileorg.springframework:spring-webmvc:jar:5.2.11.RELEASE:compilecom.sun.jersey:jersey-core:jar:1.19.1:runtimejavax.ws.rs:jsr311-api:jar:1.1.1:runtimejavax.inject:javax.inject:jar:1:runtimeorg.springframework.cloud:spring-cloud-openfeign-core:jar:2.2.6.RELEASE:compilecom.netflix.ribbon:ribbon-core:jar:2.3.0:compilecom.netflix.hystrix:hystrix-core:jar:1.5.18:compilecom.netflix.ribbon:ribbon-transport:jar:2.3.0:runtimeorg.springframework.boot:spring-boot-starter-json:jar:2.3.6.RELEASE:compileorg.springframework.cloud:spring-cloud-starter-openfeign:jar:2.2.6.RELEASE:compilecom.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.3:compilecom.sun.jersey.contribs:jersey-apache-client4:jar:1.19.1:runtimeio.github.openfeign:feign-hystrix:jar:10.10.1:compileio.github.openfeign:feign-slf4j:jar:10.10.1:compilecom.alibaba.nacos:nacos-client:jar:1.4.2:compileorg.apache.httpcomponents:httpcore-nio:jar:4.4.13:compilecom.sun.jersey:jersey-client:jar:1.19.1:runtimeorg.springframework.cloud:spring-cloud-context:jar:2.2.6.RELEASE:compileorg.glassfish:jakarta.el:jar:3.0.3:compileorg.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compilecom.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.3:compileorg.springframework.cloud:spring-cloud-commons:jar:2.2.6.RELEASE:compileorg.aspectj:aspectjweaver:jar:1.9.6:compilecom.alibaba.cloud:spring-cloud-starter-alibaba-nacos-discovery:jar:2.2.6.RELEASE:compilecom.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compilecom.alibaba.spring:spring-context-support:jar:1.0.10:compilejakarta.annotation:jakarta.annotation-api:jar:1.3.5:compileorg.bouncycastle:bcpkix-jdk15on:jar:1.64:compilecom.netflix.netflix-commons:netflix-commons-util:jar:0.3.0:runtimecom.fasterxml.jackson.core:jackson-annotations:jar:2.11.3:compilecom.google.guava:guava:jar:29.0-jre:compilecom.google.guava:failureaccess:jar:1.0.1:compileorg.springframework.boot:spring-boot:jar:2.3.6.RELEASE:compilecom.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.3:compilecom.atguigu.demo:demo08-base-api:jar:1.0-SNAPSHOT:compileorg.springframework.cloud:spring-cloud-starter-netflix-archaius:jar:2.2.6.RELEASE:compileorg.springframework.boot:spring-boot-autoconfigure:jar:2.3.6.RELEASE:compileorg.slf4j:slf4j-api:jar:1.7.30:compilecommons-io:commons-io:jar:2.7:compileorg.springframework.cloud:spring-cloud-starter:jar:2.2.6.RELEASE:compileorg.apache.tomcat.embed:tomcat-embed-core:jar:9.0.39:compileio.reactivex:rxnetty:jar:0.4.9:runtimecom.fasterxml.jackson.core:jackson-core:jar:2.11.3:compilecom.google.code.findbugs:jsr305:jar:3.0.2:compilecom.netflix.archaius:archaius-core:jar:0.7.6:compileorg.springframework.boot:spring-boot-starter-web:jar:2.3.6.RELEASE:compilecommons-codec:commons-codec:jar:1.14:compilecom.netflix.servo:servo-core:jar:0.12.21:runtimecom.google.errorprone:error_prone_annotations:jar:2.3.4:compileorg.attoparser:attoparser:jar:2.0.5.RELEASE:compilecom.atguigu.demo:demo10-base-util:jar:1.0-SNAPSHOT:compileorg.checkerframework:checker-qual:jar:2.11.1:compileorg.thymeleaf:thymeleaf-spring5:jar:3.0.11.RELEASE:compilecommons-fileupload:commons-fileupload:jar:1.4:compilecom.netflix.ribbon:ribbon-httpclient:jar:2.3.0:compilecom.netflix.netflix-commons:netflix-statistics:jar:0.1.1:runtimeorg.unbescape:unbescape:jar:1.1.6.RELEASE:compileorg.springframework:spring-jcl:jar:5.2.11.RELEASE:compilecom.alibaba.nacos:nacos-common:jar:1.4.2:compilecommons-collections:commons-collections:jar:3.2.2:runtimejavax.persistence:persistence-api:jar:1.0:compilecom.alibaba.nacos:nacos-api:jar:1.4.2:compileorg.thymeleaf:thymeleaf:jar:3.0.11.RELEASE:compileorg.springframework:spring-aop:jar:5.2.11.RELEASE:compileorg.springframework.boot:spring-boot-starter:jar:2.3.6.RELEASE:compileorg.springframework.boot:spring-boot-starter-tomcat:jar:2.3.6.RELEASE:compileorg.springframework.cloud:spring-cloud-netflix-ribbon:jar:2.2.6.RELEASE:compileorg.springframework:spring-expression:jar:5.2.11.RELEASE:compileorg.springframework.cloud:spring-cloud-netflix-archaius:jar:2.2.6.RELEASE:compile 而如果使用 Maven 来引入这些 jar 包只需要配置三个『依赖』： ②jar 包的来源 这个jar包所属技术的官网。官网通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载。 第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。 jar包的名称 jar包的版本 jar包内的具体细节 而使用 Maven 后，依赖对应的 jar 包能够自动下载，方便、快捷又规范。 ③jar 包之间的依赖关系框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。 下面是前面例子中 jar 包之间的依赖关系： 而实际上 jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。 而使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量。 2、Maven 作为构建管理工具①你没有注意过的构建你可以不使用 Maven，但是构建必须要做。当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。 ②脱离 IDE 环境仍需构建 3、结论 管理规模庞大的 jar 包，需要专门工具。 脱离 IDE 环境执行构建操作，需要专门工具。 第二节 What？什么是 Maven？Maven 是 Apache 软件基金会组织维护的一款专门为 Java 项目提供构建和依赖管理支持的工具。 1、构建Java 项目开发过程中，构建指的是使用『原材料生产产品』的过程。 原材料 Java 源代码 基于 HTML 的 Thymeleaf 文件 图片 配置文件 …… 产品 一个可以在服务器上运行的项目 构建过程包含的主要的环节： 清理：删除上一次构建的结果，为下一次构建做好准备 编译：Java 源程序编译成 *.class 字节码文件 测试：运行提前准备好的测试程序 报告：针对刚才测试的结果生成一个全面的信息 打包 Java工程：jar包 Web工程：war包 安装：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入 Maven 仓库 部署 部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上 部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上 2、依赖如果 A 工程里面用到了 B 工程的类、接口、配置文件等等这样的资源，那么我们就可以说 A 依赖 B。例如： junit-4.12 依赖 hamcrest-core-1.3 thymeleaf-3.0.12.RELEASE 依赖 ognl-3.1.26 ognl-3.1.26 依赖 javassist-3.20.0-GA thymeleaf-3.0.12.RELEASE 依赖 attoparser-2.0.5.RELEASE thymeleaf-3.0.12.RELEASE 依赖 unbescape-1.1.6.RELEASE thymeleaf-3.0.12.RELEASE 依赖 slf4j-api-1.7.26 依赖管理中要解决的具体问题： jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地 jar 包之间的依赖：通过依赖的传递性自动完成 jar 包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入 3、Maven 的工作机制 第二章 Maven 核心程序解压和配置第一节 Maven 核心程序解压与配置1、Maven 官网地址首页： Maven – Welcome to Apache Maven(opens new window) 下载页面： Maven – Download Apache Maven(opens new window) 下载链接： 2、解压Maven核心程序核心程序压缩包：apache-maven-3.8.4-bin.zip，解压到非中文、没有空格的目录。例如： 在解压目录中，我们需要着重关注 Maven 的核心配置文件：conf&#x2F;settings.xml 3、指定本地仓库本地仓库默认值：用户家目录&#x2F;.m2&#x2F;repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中 jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以建议将 Maven 的本地仓库放在其他盘符下。配置方式如下： 本地仓库这个目录，我们手动创建一个空的目录即可。 记住：一定要把 localRepository 标签从注释中拿出来。 注意：本地仓库本身也需要使用一个非中文、没有空格的目录。 4、配置阿里云提供的镜像仓库Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，访问国内网站，可以让 Maven 下载 jar 包的时候速度更快。配置的方式是： ①将原有的例子配置注释掉 ②加入我们的配置将下面 mirror 标签整体复制到 settings.xml 文件的 mirrors 标签的内部。 5、配置 Maven 工程的基础 JDK 版本如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：将 profile 标签整个复制到 settings.xml 文件的 profiles 标签内。 第二节 配置环境变量1、检查 JAVA_HOME 配置是否正确Maven 是一个用 Java 语言开发的程序，它必须基于 JDK 来运行，需要通过 JAVA_HOME 来找到 JDK 的安装位置。 可以使用下面的命令验证： 2、配置 MAVEN_HOME TIPS 配置环境变量的规律： XXX_HOME 通常指向的是 bin 目录的上一级 PATH 指向的是 bin 目录 3、配置PATH 4、验证 第三章 使用 Maven：命令行环境第一节 实验一：根据坐标创建 Maven 工程1、Maven 核心概念：坐标①数学中的坐标 使用 x、y、z 三个『向量』作为空间的坐标系，可以在『空间』中唯一的定位到一个『点』。 ②Maven中的坐标[1]向量说明使用三个『向量』在『Maven的仓库』中唯一的定位到一个『jar』包。 groupId：公司或组织的 id artifactId：一个项目或者是项目中的一个模块的 id version：版本号 [2]三个向量的取值方式 groupId：公司或组织域名的倒序，通常也会加上项目名称 例如：com.atguigu.maven artifactId：模块的名称，将来作为 Maven 工程的工程名 version：模块的版本号，根据自己的需要设定 例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本 例如：RELEASE 表示正式版本 举例： groupId：com.atguigu.maven artifactId：pro01-atguigu-maven version：1.0-SNAPSHOT ③坐标和仓库中 jar 包的存储路径之间的对应关系坐标： 上面坐标对应的 jar 包在 Maven 本地仓库中的位置： 一定要学会根据坐标到本地仓库中找到对应的 jar 包。 2、实验操作①创建目录作为后面操作的工作空间例如：D:&#x2F;maven-workspace&#x2F;space201026 有危险Σ(っ °Д °;)っ WARNING 此时我们已经有了三个目录，分别是： Maven 核心程序：中军大帐 Maven 本地仓库：兵营 本地工作空间：战场 ②在工作空间目录下打开命令行窗口 ③使用命令生成Maven工程 运行 mvn archetype:generate 命令 下面根据提示操作 TIPS Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:【直接回车，使用默认值】 Define value for property ‘groupId’: com.atguigu.maven Define value for property ‘artifactId’: pro01-maven-java Define value for property ‘version’ 1.0-SNAPSHOT: :【直接回车，使用默认值】 Define value for property ‘package’ com.atguigu.maven: :【直接回车，使用默认值】 Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro01-maven-java version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认。如果前面有输入错误，想要重新输入，则输入 N 再回车。】 ④调整Maven 默认生成的工程，对 junit 依赖的是较低的 3.8.1 版本，我们可以改成较适合的 4.12 版本。 自动生成的 App.java 和 AppTest.java 可以删除。 ⑤自动生成的 pom.xml 解读 3、Maven核心概念：POM①含义POM：Project Object Model，项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。 ②模型化思想POM 表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。 ③对应的配置文件POM 理念集中体现在 Maven 工程根目录下 pom.xml 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。 4、Maven核心概念：约定的目录结构①各个目录的作用 另外还有一个 target 目录专门存放构建操作输出的结果。 ②约定目录结构的意义Maven 为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用。例如：Maven 执行编译操作，必须先去 Java 源程序目录读取 Java 源代码，然后执行编译，最后把编译结果存放在 target 目录。 ③约定大于配置Maven 对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建 Maven 工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。 目前开发领域的技术发展趋势就是：约定大于配置，配置大于编码。 第二节 实验二：在 Maven 工程中编写代码1、主体程序 主体程序指的是被测试的程序，同时也是将来在项目中真正要使用的程序。 2、测试程序 第三节 实验三：执行 Maven 的构建命令1、要求运行 Maven 中和构建操作相关的命令时，必须进入到 pom.xml 所在的目录。如果没有在 pom.xml 所在的目录运行 Maven 的构建命令，那么会看到下面的错误信息： TIPS mvn -v 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录。 2、清理操作mvn clean 效果：删除 target 目录 3、编译操作主程序编译：mvn compile 测试程序编译：mvn test-compile 主体程序编译结果存放的目录：target&#x2F;classes 测试程序编译结果存放的目录：target&#x2F;test-classes 4、测试操作mvn test 测试的报告存放的目录：target&#x2F;surefire-reports 5、打包操作mvn package 打包的结果——jar 包，存放的目录：target 6、安装操作mvn install 安装的效果是将本地构建过程中生成的 jar 包存入 Maven 本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。 坐标信息如下： 在 Maven 仓库中生成的路径如下： 另外，安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。 第四节 实验四：创建 Maven 版的 Web 工程1、说明使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。这个专门生成 Web 工程骨架的 archetype 可以参照官网看到它的用法： 参数 archetypeGroupId、archetypeArtifactId、archetypeVersion 用来指定现在使用的 maven-archetype-webapp 的坐标。 2、操作注意：如果在上一个工程的目录下执行 mvn archetype:generate 命令，那么 Maven 会报错：不能在一个非 pom 的工程下再创建其他工程。所以不要再刚才创建的工程里再创建新的工程，请回到工作空间根目录来操作。 然后运行生成工程的命令： 下面的操作按照提示执行： TIPS Define value for property ‘groupId’: com.atguigu.maven Define value for property ‘artifactId’: pro02-maven-web Define value for property ‘version’ 1.0-SNAPSHOT: :【直接回车，使用默认值】 Define value for property ‘package’ com.atguigu.maven: :【直接回车，使用默认值】 Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro02-maven-web version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认】 ####3、生成的pom.xml 确认打包的方式是war包形式 4、生成的Web工程的目录结构 webapp 目录下有 index.jsp WEB-INF 目录下有 web.xml 5、创建 Servlet①在 main 目录下创建 java 目录 ②在 java 目录下创建 Servlet 类所在的包的目录 ③在包下创建 Servlet 类 ④在 web.xml 中注册 Servlet 6、在 index.jsp 页面编写超链接 TIPS JSP全称是 Java Server Page，和 Thymeleaf 一样，是服务器端页面渲染技术。这里我们不必关心 JSP 语法细节，编写一个超链接标签即可。 7、编译此时直接执行 mvn compile 命令出错： 当心哦≧ ﹏ ≦ DANGER 程序包 javax.servlet.http 不存在 程序包 javax.servlet 不存在 找不到符号 符号: 类 HttpServlet …… 上面的错误信息说明：我们的 Web 工程用到了 HttpServlet 这个类，而 HttpServlet 这个类属于 servlet-api.jar 这个 jar 包。此时我们说，Web 工程需要依赖 servlet-api.jar 包。 8、配置对 servlet-api.jar 包的依赖对于不知道详细信息的依赖可以到  网站查询。使用关键词搜索，然后在搜索结果列表中选择适合的使用。 比如，我们找到的 servlet-api 的依赖信息： 这样就可以把上面的信息加入 pom.xml。重新执行 mvn compile 命令。 9、将 Web 工程打包为 war 包运行 mvn package 命令，生成 war 包的位置如下图所示： 10、将 war 包部署到 Tomcat 上运行将 war 包复制到 Tomcat&#x2F;webapps 目录下 启动 Tomcat： 通过浏览器尝试访问： 第五节 实验五：让 Web 工程依赖 Java 工程第六节 实验六：测试依赖范围第七节 实验七：测试依赖的传递性第八节 实验八：测试依赖的排除第九节 实验九：继承第十节 实验十：聚合第四章 使用 Maven：IDEA环境第五章 其他核心概念第六章 单一架构案例第二只锦囊 学完 SSM 后打开第七章 SSM 整合伪分布式案例第三只锦囊 学完微服务后打开第八章 微服务架构案例第九章 POM 深入与强化第十章 生产实践"},{"title":"【动漫】【置顶】动漫列表-长期更新","date":"2024-04-02T09:47:25.000Z","url":"/subweb/blog/2024/04/02/0012.%E5%8A%A8%E6%BC%AB%E5%88%97%E8%A1%A8-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/","tags":[["动漫","/subweb/blog/tags/%E5%8A%A8%E6%BC%AB/"],["日漫","/subweb/blog/tags/%E6%97%A5%E6%BC%AB/"],["原盘","/subweb/blog/tags/%E5%8E%9F%E7%9B%98/"]],"categories":[["动漫","/subweb/blog/categories/%E5%8A%A8%E6%BC%AB/"]],"content":"说明更新时间：2025-2-13 13:36:25 列表内容均参考自泛式的新番导视视频。 各种前置标记为优先级，从高到低分别为 @、 # 、$、 % 加粗字体表示正在下载 删除线字体表示已经下载完毕 列表2023-72023-10续作组0:15-《进击的巨人 完结篇 后篇》 （进击的巨人 全集 均下载完毕）0:26-《间谍过家家2》#0:37-《偶像大师 百万现场》文艺复兴重置版0:48-《恶魔君》 《仙魔大战》0:52-《想要成为影之实力者2》0:54-《哥布林杀手2》0:56-《世界尽头的圣骑士2》0:58-《圣女魔力无所不能2》1:00-《女友成堆2》1:02-《铁路浪漫谭2》1:04-《拳愿阿修罗2》1:06-《催眠麦克风2》1:07-《绊之Allele2》#1:09-《盾之勇者成名录3》1:11-《亡骸游戏2》1:12-《石纪元 新世界part2》1:14-《魔法使新娘2part2》1:16-《东京复仇者 天竺篇》1:18-《足球小将 世少篇》1:20-《七大罪:默示录的四骑士》1:23-《B-PRIJECT～热烈字符号*Love Call ～》1:24-《赛马娘3》新作组#1:49-《葬送的芙莉莲》由MAD HOUSE担当制作导演:斋藤圭一 其他作品:《孤独摇滚》#3:03-《不死不幸》由大卫社担当制作《炎炎消防队》3:29-《药屋少女的呢喃》导演:長沼範裕 其他作品:《魔法新娘使》3:59-《超超超超喜欢你的100个女朋友》4:32-《位于恋爱光谱极端的我们》别名:《经验丰富的你与经验为零的我交往的故事》4:57-《腼腆英雄》5:28-《星灵感应》5:54-《狩龙人拉格纳》由Silver Link制作6:30-《破灭之国》6:54-《鸭乃桥论的禁忌推理》漫画作者:天野明 其他作品:《家庭教师》7:16-《米奇与达利》作者:佐野菜见老师（R.I.P） 其他作品:《在下坂本》8:02-《地下忍者》由手冢P制作8:32-《特搜组大吾 救国的橘色部队》8:59-《16bit的感动》9:37-《凹凸魔女的亲子日常》9:44-《柚木家的四兄弟》9:53-《晚安世界》10:06《大小姐与看门犬》10:20-《极速车魂》10:29-《圣剑学院的魔剑使》原作:志瑞祐 其他作品；《精灵使的剑舞》10:52-《家里蹲吸血姬的苦闷》由P9担当制作 #11:19-《靠着魔法药水在异世界活下去》作者:FUNA 其他作品:《能力平均值》《养老八万金》#11:34-《提亚穆帝国物语～从断头台开始，公主重生的逆转人生》**#11:48-《我推是反派大小姐》#12:04-《捡走被人悔婚的千金，教会她坏坏的幸福生活》12:18-《想当冒险者前往大都市的儿女已经升到了5级》12:32-《猪肝记得煮熟再吃》12:53-《暴食狂战士～只有我突破了等级概念～》13:12-《归还者的魔法要特别》13:28-《莫大叔的VRMMO活动记》#13:52-《香格里拉边境～粪作猎人向神作游戏发起挑战～》14:15-《KamiErabi》原创企划:JIN14:23-《Overtake》执导:青木英 同时是《fate&#x2F;zero》《异度入侵》的导演14:28-《Paradox Live THE ANIMATION》14:31-《川越男子合唱团》#14:37-《我们的雨色协议》14:59-《PLUTO～冥王》原作:浦泽直树 由网飞出品 2024-1续作 @我心里危险的东西2 龙与魔女 #0.8 奇异贤伴 黑色天使 part2 青之驱魔师 岛根启明结社篇 通灵王 FLOWERS 福星小子 重制版 2 #物理魔法使马修 2 狩火之王 2 至高之牌 2 月光下的异世界之旅 2 因为不是真正的伙伴被赶出勇者队伍 2 弱角友崎同学 2 欢迎来到实力至上主义教师 3 王者天下 5 《王者天下 5》 《暗芝居 12》 《卡片战斗先导者 ？？？》 新作 #《迷宫饭》 @《我独自升级》 《魔女与野兽》 #《魔都精灵的奴隶》 #《憧憬成为魔法少女》 《休假日的坏人先生》 #《愚蠢天使与恶魔共舞》 #《公主大人“拷问时间到”》 《佐佐木与文鸟小哔》 #《为了在异世界抚摸毛茸茸而努力》 #《最弱驯兽师开启捡垃圾旅途》 《事与愿违的不死冒险者》 《治愈魔法的错误使用方法奔赴战场的回复要员》 @《秒杀外挂太强了，异世界的家伙根本不是对手》 《最强肉盾的迷宫攻略~拥有稀有技能血量9999的肉盾被勇者队伍辞退》 #《恶役千金lv99我是隐藏boss但不是魔王》 #《外科医生爱丽丝》 #《轮回七次的恶役千金，在前敌国享受随心所欲的新婚生活》 《异修罗》 #《指尖相触，恋恋不舍》 《战国妖狐》 《北海道辣妹贼拉可爱》 《百千家的妖怪王子》 《到了30岁还是童真似乎会变成魔法师》 《婚戒物语》 原创 《勇气爆发Bang Bravern》 #《碰之道》 《月刊妄想科学》 《Bucchigiri》 《Metallic Rouge》 2024-4续作组： 《京吹 3》 《为美好的世界献上祝福 3》 + 三部老番重制版 《调酒师 神之杯》 《狼与香辛料 行商邂逅贤狼》 《新·亚拉那一卡》 《无知转生 2 part2》 《转生史莱姆 3》（半年，整部下载） 《死神少爷与黑女仆 3》 《魔法科高校劣等生 3》 《约会大作战 5》 《虹四格动画 2》 《影之诗F ArkRuler篇》 《秘密偶像公主》（美妙系列新作） 《新干线变形机器人 改变世界》 《黑执事 -寄宿学校篇-》 《鬼灭之人 柱训练篇》 新作： 《怪兽8号》 《恋语轻唱》 《战队大失格》 《爷爷奶奶返老还童》 《格斗实况》 《杀手寓言》 《防风少年》 @《夜樱家大作战》（半年番） 《渴求游戏之神》 《怪人的沙拉碗》 @《声优广播的幕前幕后》 《无名记忆》 《良禽不择木》 《单间、光照尚好、附带天使》 @《吸血鬼男子宿舍》 《我回来了，欢迎回来》 《与妖为邻》 @《喂！蜻蜓》 《失忆投捕》 《怪异与少女与神隐》 《被称为废物的原英雄，被家里流放随心所欲活下去》 《身为魔王的我娶了奴隶精灵为妻，该如何表白我的爱？》 《转生为第七王子，随心所欲的魔法学习之路》 《从Lv2开始开挂的原勇者候补悠闲的异世界生活》 《转生贵族靠着鉴定技能一飞冲天》 《Re:Monster》 游戏改编动画： 《刀剑乱舞 廻 -虚传 燃烧的本能寺-》 《偶像大师 闪耀色彩》 @《雀魂 杠！！》 《碧蓝档案 动画版》 原创： 《アスト曰&#x2F;オト》《Astro Note》（暂译：外星笔记） 《未班列车去哪里？》 《竞轮少女》 《HIGHSPEED Etoile》(暂译:高速星辰) 《GIRLS BAND CRY》（哭泣少女乐队） 《夜晚的水母不游泳》 《格林童话变奏曲》 2024-7续作和衍生作 妖精的尾巴，百年任务 @物语系列外传季怪物季 好想告诉你3 筋肉人完美超人始祖篇 古连泰沙U @我推的孩子第2季 时光巡逻队第2季 神之塔第2季 腼腆英雄第二季 这是你与我之间的战争第二季 @女神露天咖啡厅第2季 卡片战斗先导者第2季 尼尔自动人形第2部分 拳愿阿修罗2第2部分 战国妖狐千魔混沌篇 新作 败犬女主太多了 @不时轻声以俄语遮羞的邻座艾莉同学 擅长逃跑的殿下 小市民系列 @义妹生活 @恋爱没法用双子除尽 @2.5次元的诱惑 @疑似后宫 $鹿乃子乃子虎视眈眈 #杖与剑的魔剑谭 为何我的世界被遗忘了 $精灵小姐瘦不了 鬼人幻灯抄 $这个世界漏洞百出 @地下城里的人们 $异世界失格 魔王军最强的魔术师是人类 异世界悠闲纪行 边养娃边当冒险者 再见地球 魔道祖师塔利亚永不妥协 从路人角色开始的探索英雄谭 依靠被嫌弃的状态异能技能而成为最强的我最终蹂躏一切 我要招架一切反误解世界最强想成为冒险家 $大叔新人冒险者被最强小队拼死锻炼后无敌了 @亚托莉我挚爱的时光 #天穗之咲稻姬 拉面赤猫 黄昏失焦 德里科的托儿所 ?我的妻子没有感情-(人外？) #前辈是男孩子 #魔法少女与恶曾是敌人 身为vtuber的我忘记关台而成为传说 原创动画 #深夜冲击 #少女如草花绽放（亦叶亦花） 异世界自杀小队 哎咕岛消失的舔甜歌姬 2024-10续作 Re0 S3第一部分 死神 千年血战篇 相克谭 夏目友人帐 S7 乱马1&#x2F;2 重制版 龙珠 大魔 蓝色监狱 S2 刀剑神域外传 GGO S2 七大罪 默示录四骑士 S2 鸭乃桥论的禁忌推理 S2 急速车魂 S2 喂！蜻蜓 S2 百姓贵族 S2 神选 S2 香格里拉开拓边境 S2 精灵幻想记 S2 重来吧魔王大人 S2 转生贵族凭鉴定技能扭转人生 S2 平凡职业早就世界最强 S3 期待在地下城邂逅有错么 S5 Beastars 最终季 青之驱魔师 雪之尽头篇 新网球王子 U-17 世界杯半决赛 浪客剑心 京都动乱篇 Love Live! Superstar!! S3 偶像大师 闪耀色彩 S2 新作 #地。关于地球的运动（半年番） #青之箱 #真的要结婚吗 #缘结甘神家（半年番） #暗杀女仆冥土小姐 #可爱史莱姆噗尼露 #妻子变成小学生 @冻牌 地下麻将斗牌录（半年番） 一兆游戏（半年番） @悲喜渔生 唯愿来世不相识 ￥村井之恋 %到了联谊会发现一个女生都没有 %辰星降临之国的妮娜 %成为名垂青史的恶役千金吧 #重启人生的千金小姐正在攻略龙帝陛下 ￥再见龙生，你好人生 %被队伍驱逐的治愈师其实是最强的 ￥一个人的异世界攻略（独自十众的异世界攻略） 最狂辅助职业【话术士】世界最强战团听我号令 %魔王2099 叹息的亡灵好像隐退 %柔光魔女股份有限公司 #Acro Trip 妖怪学校的新人教室 稗(bai)记舞咏 青之任生狼 决斗大师 LOST~追忆的水晶 #常规脱离Creative（gal改） 科学x冒险与生存! 监禁区域 Level X 转生成猫的大叔 %蘑菇狗 殿下与狗 #没能成为魔法师的女孩子的故事 ネガポジアングラー(正负极钓手) ￥机械手臂 ￥超自然武装当哒当 2025-1续作组 药屋少女的呢喃2 @超超超超超喜欢你的100个女朋友 Fate&#x2F;Strange Fake @BanG Dream! Ave Mujica 我独自升级2 异修罗2 无名记忆2 我的幸福婚姻2 地缚少年花子君2 众星齐聚2 魔法使光之美少女2 筋肉人 完美超人师祖篇2 石纪元最终季（爷青结） BEASTARS最终季（哦耶） 不死不幸一小时续集 卡片战斗先导者续篇 魔神创造传（这位更是重量级） 灰色：幻影扳机 @Re从零开始的异世界生活3反击篇 新作组 坂本日常 @舞冰的祈愿 @群花绽放，彷如修罗 #天久鹰央的推理病历表 嘻嘻嘻嘻吸血鬼 @我的可爱对黑岩目高不管用 @喜欢的冲绳妹说方言 #我和班上最讨厌的女生结婚了 #这公司有我喜欢的人 #不知为何我和家里蹲女忍者开始同居生活 异世界 ￥脱离了A级队伍的我，和从前的徒弟前往迷宫深处 #S级怪兽“贝希摩斯”被误认成小猫，成为精灵女孩的骑士（宠物）一起生活 $不幸职业【鉴定士】实则最强 %最弱技能《果实大师》～关于我能无限食用技能果实（吃了就会死）这件事 #魔法制造者～异世界魔法的制作方法~ #虽然是公会的前台小姐，因为讨厌加班打算自己讨伐boss #欢迎来到日本，精灵小姐。 中年男的异世界网购生活 终将成为最强炼金术师？ $虽然我是注定没落的贵族闲来无事只好深究魔法 ^暂定名：身为圣女的我却被国家驱逐来到濒临崩坏的邻国只好解放神力守护世界和平（不包括把我赶出去的国家） #战队红战士在异世界当冒险者 #中年大叔转生恶役大小姐 魔域英雄传说 #蜂蜜柠檬碳酸水 $终究，与你相恋 %黄昏旅店 魔法使的约定 $魔农传记 想星的大天使 #一杆青空 @全修。 ￥Momentary Lily "},{"title":"【错题本】考研-2024-计算机网络错题本","date":"2023-12-23T06:51:25.000Z","url":"/subweb/blog/2023/12/23/0016.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%94%99%E9%A2%98%E6%9C%AC/","tags":[["研究生考试","/subweb/blog/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95/"],["计算机","/subweb/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"],["学习","/subweb/blog/tags/%E5%AD%A6%E4%B9%A0/"],["408","/subweb/blog/tags/408/"],["错题本","/subweb/blog/tags/%E9%94%99%E9%A2%98%E6%9C%AC/"],["计算机网络","/subweb/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["学习","/subweb/blog/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"计算机网络错题本王道考研-2024-计算机网络考研复习指导第一章 计算机网络体系结构p007-1.1.7 计算机网络的三大主要功能是数据通信、资源共享及分布式处理。计算机网络使各计算机之间的联系更加紧密。因此在一定程度上，计算网络能提高系统可靠性。 计算机网络系统的基本组成，即从逻辑功能上可分为：通信子网和资源子网。 从物理组成来看，计算机网络由硬件、软件和协议组成，客户机是客户访问网络的出入口，服务器是提供访问、存储信息的设备，是计算机网络中必不可少的。操作系统是最基本的软件，因此也是必不可少的。诸如数据库管理系统等软件，由于一个网络上可以没有数据库系统，所以数据库管理系统可能没有。 广域网和局域网之间的差异不仅在于它们所覆盖范围的不同，还在于它们所采用的协议和网络技术的不同，广域网使用点对点等技术，局域网使用广播技术。（仅在远远落后于时代的大学教材） 区别广域网和局域网的关键在于其所用协议，而非覆盖范围。 城域网可视为为了满足一定的区域需求，而将多个局域网互连的局域网，因此它仍属于以太网范畴。 最初的局域网采用广播技术，且一直被沿用，最初的广域网使用是交换技术，也一直被沿用。（仅在远远落后于时代的大学教材） 目前局域网接入广域网主要是通过路由器实现的。 中继器和桥接器通常是指用于局域网的物理层和数据链路层的联网设备。 广播式网络共享广播信道（如总线），通常是局域网的一种通信方式（局域网工作在数据链路层），因此不需要网络层。因此也不存在路由选择问题。但数据链路层使用**物理层的服务必须通过服务访问点实现**。 分组交换要求把数据分成大小相当的小数据片，每片都要加上控制信息（如目的地址等），因而传输数据的总开销较多，相比其它交换方式，分组交换信道利用率高。传播时延取决于传播介质及收发双方的距离。 对各种交换方式，不同规格的终端都很难相互通信。 对于分组发送文件中对分组确认和接收完全部分组对文件确认两种策略的对比 电路交换和报文交换：电路交换中，只要建立好通信信道，就可以连续不断的一直发送数据，可以不考虑中间的站点。报文交换需要将一个报文全部接收后，才能发给下一个站点，与此同时，上一个站点开始发送下一个包。因此对于时延的计算，电路交换的时延为$电路交换时延&#x3D;连接时延+发送时延+传播时延$，分组交换的时延为$分组交换时延&#x3D;发送时延+传播时延$，但在实际计算中，分组交换的时延可以看作$第一个报文发送到终点的时延+每个包从倒数第二个站点发送到最后一个站点的时延$。 p021-1.2.4 网络模型进行分层的目标：提供标准语言，定义标准界面，增加功能之间的独立性。 将用户数据分成一个个数据块传输的优点：减少延迟时间，提高错误控制效率，使多个应用公平的使用共享通信介质。 OSI&#x2F;ISO参考模型 主要功能 物理层（比特） 在物理媒体上为数据端设备透明地传输原始比特流①定义数据终端设备和数据通信设备的物理与逻辑连接方法②定义传输模式 ③定义传输速率④比特同步 ⑤比特编码 数据链路层（帧） 将网络层传来的IP数据报封装成帧①成帧 ②差错控制 ③流量控制 ④传输管理 ⑤访问接入控制 网络层（数据报） 把网络层的协议数据单元（分组）从源端传到目的端①路由选择 ②流量控制 ③拥塞控制 ④差错控制 ⑤网际互连 传输层（报文段(TCP)或用户数据报(UDP)） 利用通信子网为端到端连接提供可靠服务①可靠服务 ②端到端流量控制 ③差错控制 ④服务质量、数据传输管理⑤服用分用 ⑥分组排序 会话层 允许不同主机上的两个进程之间进行会话①建立、管理及终止进程间的会话 ②使用校验点使通信会话在失效时从校验点继续恢复通信，实现数据同步 表示层 处理在两个通信系统中交换信息的表示方式（语法语义）①采用标准的编码格式（格式变换） ②数据压缩③加密和解密 应用层 为特定类型的网络应用提供访问OSI参考模型环境的手段①文件传输协议FTP ②电子邮件协议SMTP ③万维网HTTP OSI&#x2F;ISO中可同时提供无连接服务和面向连接服务的是网络层。TCP&#x2F;IP中则是传输层。 集线器工作在物理层，交换机和网桥在数据链路层，易错。[坑] 协议和服务的区别和联系： 一个分组被送到错误的目的站：网络层出现问题——网络层的PDU称为分组，分组转发是网络层的功能。 一个半双工的会话中，正在发送数据的用户突然接收到对方用户发来的数据：会话层出现错误——会话层允许不同主机上的进程进行会话。 第二章 物理层p040-2.1.6 根据香农公式可得出，影响信道最大传输速率的因素主要有：信道带宽和信噪比。 并行传输：距离短，速度快；串行传输：距离长，速度慢。因此计算机内部的数据传输主要是并行传输，外部主要是串行传输。 以太网默认采用曼彻斯特编码，2个码元编码一个bit，故波特率是数据率的两倍。 TDM（时分复用）的复用线路最小通信能力要满足最大通信速度的那一路的n倍（n为通信路数）。 报文交换由于大小不固定，在交换节点中需要较大的存储空间，另外报文经过中间节点的接收、存储和转发时间较长而且不固定，因此报文交换不适合于实时通信应用环境（音视频）。 三种数据交换方式优缺点 虚电路不只是临时性的，它提供的服务包括**永久性虚电路(PVC)和交换型虚电路(SVC)**，其中前者是一种提前定义好的、基本上不需要任何建立时间的端点之间的连接，而后者是端点之间的一种临时性连接，这些连接只持续所需的时间，并且在会话结束时就取消这种连接。 数据报服务中，每个分组在传输中都必须携带源地址和目的地址。 在数据进行分组转发的过程中，要接收完一整个分组才会转发该分组，第一个分组在发送时会产生转发时延，后面虽然也有转发时延，但基本上与前一个分组的转发时延相连，故计算时延时，可以计算源主机发送时延+转发次数*单次转发的时延（分组大小&#x2F;数据传输速率）。 信道数据传输速率于信号传播速度无关。 虚电路传输不需要预分配带宽。 时延带宽积的含义是：发送方收到一个响应之前能发送的数据量。 计算发出请求到接收完数据时，应考虑开始受到第一个位时，已经过了一个RTT。 下题作为积累 ​ ​ p054-2.2.3 同轴线缆的通信方式位半双工。 同轴线缆传输速率更快得益于其有更好的抗噪声性。 单模光纤的光源为定向性很好的半导体激光器，衰减很小，适合远距离传输，若光纤直径小到只有光的一个波长，则光沿直线传播。 多模光纤的光源为发光二极管，光脉冲在多模光纤中传输会逐渐展宽，造成失真，只适合近距离传输。 物理层的机械特性：引脚，形状；电器特性：电压范围，速率，距离；功能特性：不同电平的含义；规程特性（过程特性）：规程和时序。 集线器的一个端口接收到数据后，会从除了接受的端口外的其它所有端口广播出去，而不是直接所有。 第三章 数据链路层p064-3.1.6 数据链路层的主要功能包括组帧（定义数据格式）；数据链路层在物理层提供的不可靠物理连接上实现节点到节点的可靠性传输；控制物理传输介质的访问由数据链路层的介质访问控制（MAC）子层完成。 为终端隐藏物理传输细节的是物理层的功能，数据链路层无需考虑如何实现无差别的比特传输。 ICMP是网络层协议。 p68-3.2.5p70-3.3.3 一般来说，数据的传输差错是由噪声引起的。通信信道的噪声可以分为两类，热噪声和冲击噪声。热噪声一般是信道固有的，引起的差错是随机差错，可以通过提高信噪比来降低它对数据传输的影响。冲击噪声一般是由外界电磁干扰引起的，引起的差错是突发差错，它是引起传输差错的主要原因，无法通过提高信噪比来避免。 CRC校验码可以检测出所有单比特错误 海明码可以纠正一位差错。（发现双比特，纠正单比特） 海明码“纠错” $d$ 位，需要码距为 $2d+1$ ;“检错” $d$ 位，需要码距 $d+1$ 对于 $k$ 位数据，如果使用海明码，需要增加的冗余信息位数 $r$ 满足： $2^r\\ge k+r+1$ 。（在 $k$ 比特信息位上附加 $r$ 比特冗余信息，构成 $k+r$ 比特的码字，再加一位成功位） CRC循环冗余校验，带 $r$ 个校验位的多项式编码可以检测到所有长度小于或等于 $r$ 的突发性错误。 CRC校验生成时，不要忘记在多项式后补零再做除法运算，且除法运算是每位异或。 p077-3.4.5 后退N帧协议（ARQ）的GBN协议要求：窗口大小比序列号的个数小1。 选择重传协议采用 $n$ 比特对帧编号，则需要满足 $W_{Tmax}&#x3D;W_{Rmax}&#x3D;2^{n-1}$ ，其中$W_{Tmax}$ 为发送窗口的最大尺寸 $W_{Rmax}$ 为接收窗口的最大尺寸。 GBN协议中，窗口总数为 $n$ ，发送窗口的大小最大为 $W_{Tmax}$ ，则：$W_{Tmax}\\le n-1$ ，接收窗口大小至少为1. 窗口大小是窗口总数，包含了发送窗口和接收窗口。 由上两条知：对于窗口大小为 $n$ 的滑动窗口，最多可以有 $n-1$ 帧已经发送但没有确认。 对于SR协议传输，题目没说就是没超时。 从滑动窗口的概念来看，停止等待协议：发送窗口大小&#x3D;1，接收窗口大小&#x3D;1；后退N帧协议：发送窗口大小&gt;1，接收窗口大小&#x3D;1；选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1。在选择重传协议中，还需要满足:发送窗口大小+接收窗口大小&lt;序号数量。且接收窗口不大于发送窗口（无意义）。 p095-3.5.4 无线局域网不能简单地使用 CSMA&#x2F;CD 协议，特别是碰撞检测部分，原因如下：第一，在无线局域网的适配器上，接收信号的强度往往远小于发送信号的强度，因此若要实现碰撞检测，那么硬件上的花费就会过大；第二，在无线局域网中，并非所有站点都能听见对方，由此引发了隐蔽站和暴露站问题，而“所有站点都能够听见对方”正是实现 CSMA&#x2F;CD 协议必备的基础。因此无线局域网不适用 CSMA&#x2F;CD 而是 CSMA&#x2F;CA 的原因可以是：不需要在发送过程中进行冲突检测。 多路复用器的主要功能是结合来自两条或多条线路的传输，以充分利用信道。 令牌环网络的特点： 不存在冲突 同一时刻只有一个数据在传输 重负载下信道利用率高 媒体的利用率比较公平 网上所有节点共享网络带宽 数据从一个结点到另一个结点的时间可以计算。 令牌环网络中，当所有站点都有数据帧要发送时，一个站点在最坏情况下等待获得令牌和发送数据帧的时间等于所有站点传送令牌和发送帧的时间的一半 对正确接收到的数据帧进行确认的MAC协议是：CSMA&#x2F;CA，正确接收后会发送ACK帧，是CSMA&#x2F;CA避免冲突的机制之一。 在计算题中，若给出是在以太网条件下，或计算时需要使用帧长的，影响到以太网的最短帧长为64B，尤其是计算以太网两台设备的最远距离时十分有用。 关于CSMA&#x2F;CA： 站A和B都在 AP 的覆盖范围内，但A和B 相距较远，彼此都听不见对方。当A 和B 检测到信道空闲时，都向 AP 发送数据，导致碰撞的发生，这就是隐蔽站问题。为了避免该问题，802.11 允许发送站对信道进行预约。 CSMA&#x2F;CA算法的归纳如下： ①若站点最初有数据要发送(而不是发送不成功再进行重传)，且检测到信道空闲，在等待时间 DIFS 后，就发送整个数据帧。 ②否则，站点执行 CSMA&#x2F;CA 退避算法，选取一个随机回退值。一旦检测到信道忙，退避计时器就保持不变。只要信道空闲，退避计时器就进行倒计时。 ③当退避计时器减到0时(这时信道只可能是空闲的)，站点就发送整个并等待确认。 ④发送站若收到确认，就知道已发送的帧被目的站正确接收。这时如果要发送第二帧，就要从步骤②开始，执行 CSMA&#x2F;CA 退避算法，随机选定一段退避时间。 若发送站在规定时间(由重传计时器控制) 内没有收到确认 ACK，就必须重传该，再次使用 CSMA&#x2F;CA 协议争用该信道，直到收到确认，或经过若干次重传失败后放弃发送。 源站要发送数据帧之前先广播一个很短的请求发送 RTS (Request To Send) 控制，它包括源地址、目的地址和这次通信 (含相应的确认帧) 所持续的时间，该顿能被其范围内包括 AP 在内的所有站点听到。若信道空闲，则AP广播一个允许发送 CTS (Cear To Send) 控制，它包括这次通信所需的持续时间 (从RTS 帧复制),该帧也能被其范围内包括 A 和 B 在内的所有站点听到。B 和其他站听到 CTS 后在CTS 帧中指明的时间内将抑制发送。 CTS 有两个目的： 给源站明确的发送许可 指示其他站点在预约期内不要发送。 集中帧间间隔（InterFrame Space，IFS） **SIFS(短IFS)**：最短的 IFS，用来分隔属于一次对话的各，使用 SIFS 的类型有 ACK帧、CTS 帧、分片后的数据帧，以及所有回答 AP 探询的等。 **PIFS (点协调IFS)**：中等长度的IFS，在PCF 操作中使用。 **DIFS(分布式协调IFS)**：最长的IFS，用于异步竞争访问的时延。 p111-3.6.5 以太网逻辑上是总线型拓扑结构，物理拓扑是星型拓扑或扩展星型拓扑。 以太网采用以下措施简化通信： 采用无连接的工作方式 不对发送的数据帧编号，也不要求接收方发送确认 在以太网中，大量的广播信息会降低整个网络性能的原因是：网络中的每台计算机都必须处理每个广播信息。 在使用静态地址的系统中，如果有重复的硬件地址（MAC），那么这两个设备都不能正常通信，原因是：①目的 MAC 地址等于本机 MAC 地址的是不会被发送到网络上去的；②其他设备的用户发送给一个设备的帧也会被另一个设备接收，其中必有一个设备必须处理不属于本设备的帧，浪费了资源；③正确实现的ARP 软件都会禁止把同一个MAC地址绑定到两个不同的IP 地址，这就使得具有相同MAC 地址的设备上的用户在会话时都发生时断时续的现象。 10BASE-T 以太网、100BASE-T 以太网、吉比特以太网都使用了 CSMA&#x2F;CD 协议，因此可以工作在半双工模式下。10 吉比特以太网只工作在全双工方式下，因此没有争用问题，也不使用CSMA&#x2F;CD 协议，且它只使用光纤作为传输介质。 快速以太网使用的方法是保持最短帧长不变，将一个网段的最大长度减少到 100m，以提高以太网的数据传输速率。 p119-3.7.4 尽管广域网的覆盖范围较大，但从互联网的角度看，广域网和局域网之间并非包含关系，而是平等的关系。 以太网是局域网的一种实现形式，其他实现形式还有令牌环网、FDDI(光纤分布数字接口IEEE 802.8)等。其中以太网的逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构。令牌环网的逻辑拓扑是环形结构，物理拓扑是尾形结构。FDDI 逻辑拓扑是环形结构，物理拓扑是双环结构。 PPP 是一种面向字节的协议，所有的帧长度都是整数个字节，使用一种特殊的字符填充法完成数据的填充。 PPP两端的网络层可以运行不同的网络层协议，但仍然能使用同一个 PPP 进行通信，因此PPP协议可以支持除IP以外的其它协议。 p124-3.8.3 网桥可以互联不同的物理层、不同的MAC子层及不同速率的以太网。 由于网桥可以使各网段相互独立，因此可以说在一定条件下增加了网络的带宽。 路由器的传输延时交大，它需要根据IP来决定是否转发分组，一般由软件完成，将带来较长的处理时间。 中继器和集线器是物理层设备，既不能隔离广播域也不能隔离冲突域。 交换机总容量为 $N*S$ ，N在全双工交换机上等于$交换机端口数$，在半双工交换机上等于 $端口数÷2$ ，S为端口带宽。 数据链路层使用物理地址进行转发。 直通交换只检查帧的目的地址，共 6B，计算传输时延只看这6B。[[]感觉有大毛病[]] 以太网交换机工作在数据链路层(因此不能实现不同网络层协议的网络互连 第四章 网络层第五章 传输层第六章 应用层"},{"title":"【错题本】考研-2024-操作系统错题本","date":"2023-12-23T06:40:25.000Z","url":"/subweb/blog/2023/12/23/0015.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%94%99%E9%A2%98%E6%9C%AC/","tags":[["操作系统","/subweb/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"],["研究生考试","/subweb/blog/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95/"],["计算机","/subweb/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"],["学习","/subweb/blog/tags/%E5%AD%A6%E4%B9%A0/"],["408","/subweb/blog/tags/408/"],["错题本","/subweb/blog/tags/%E9%94%99%E9%A2%98%E6%9C%AC/"]],"categories":[["学习","/subweb/blog/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"操作系统错题本王道考研-2024-操作系统考研复习指导第一章 计算机系统概述p005-1.1.4 源程序是一种计算机代码，是用程序设计语言编写的程序，经编译或解释后可形成具有一定功能的可执行文件，是直接面向程序员用户的，而不是操作系统的管理内容。 操作系统管理文件，是指操作系统关心计算机中的文件的逻辑结构、物理结构、文件内部结构、多文件之间如何组织的问题，而不是关心文件的具体内容。 操作系统主要向用户提供命令接口和程序接口(系统调用)，此外还提供图形接口;当然图形接口其实是调用了系统调用而实现的功能。 程序接口由一组系统调用（也称广义指令）组成。 操作系统为编程人员提供的接口是程序接口，即系统调用。作用是请求系统服务 操作系统不允许用户直接操作硬件资源，用户只能通过系统调用的方式来请求内核为其服务，间接地使用各种资源。 引入多道程序设计后，程序的执行就失去了封闭性和顺序性。程序执行因为共享资源及相互协同的原因产生了竞争，相互制约。考虑到竞争的公平性，程序的执行是断续的。顺序性是单道程序设计的基本特征。 处理机与设备，设备与设备，处理机与通道，由于是独立的，故即便在单处理机系统中也能并行。 对于多道程序系统来说，支持虚拟存储管理并非必要，即便不支持，也可以将进程全部读入主存，让多道程序并发执行。 进程数越多并不代表CPU利用率越高，进程数量越多，进程之间的资源竞争越强烈，甚至可能因为资源竞争而出现死锁现象，导致CPU利用率低。 库函数与系统调用的区别和联系：库函数是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，而且许多库函数都会使用系统调用来实现功能。未使用系统调用的库函数，其执行效率通常要比系统调用的高。因为使用系统调用时，需要上下文的切换及状态的转换 （由用户态转向核心态）。 p011-1.2.7 操作系统的基本类型主要有批处理操作系统、分时操作系统和实时操作系统。（基本类型） 实时操作系统必须在被控制对象规定时间内处理来自外部的事件。 实时系统必须能足够及时地处理某些紧急的外部事件，因此普遍用高优先级，并用”可抢占“来确保实时处理。故进程调度采用抢占式的优先级高者优先的算法。 采用优先级+非抢占式调度算法，既可让重要的作业&#x2F;进程通过高优先级尽快获得系统响应又可保证次要的作业&#x2F;进程在非抢占式调度下不会迟迟得不到系统响应，这样有利于改善系统的响应时间。相反，加大时间片会延迟系统响应时间。 分时系统追求的目标是：比较快速响应用户。 分时系统种，时间片一定时，用户数越多，响应时间越长。 多任务操作系统在同一时间内运行多个应用程序，因此有并发和并行的特点。 批处理操作系统、分时操作系统和实时操作系统的特点： 批处理操作系统的用户脱机使用计算机，作业是成批处理的，系统内多道程序并发执行,交互能力差。 分时操作系统可让多个用户同时使用计算机，人机交互性较强，具有每个用户独立使用计算机的独占性，系统响应及时。 实时操作系统能对控制对象做出及时反应，可靠性高，响应及时，但资源利用率低 甘特图画法示例： p018-1.3.4 通用操作系统使用时间片轮转调度算法，用户运行程序并不需要预先预订运行时间。 编译器是操作系统的上层软件，不是操作系统需要提供的功能。 操作系统是计算机资源的管理者，管理计算机系统资源是操作系统关心的主要问题。 系统调用需要触发陷入（trap）指令。 程序设计无法形成硬件中断，如可屏蔽中断。 中断是操作系统必须提供的功能，因为计算机的各种错误都需要中断处理，核心态与用户态切换也需要中断处理。 操作系统不允许用户直接执行某些“危险性高”的指令，因此用户态运行这些指令的结果会转成操作系统的核心态去运行。这个过程就是访管中断。 中断处理流程的前三个步骤是由硬件直接实现(隐指令)的。地址映射中需要基地址(或页表)寄存器和地址加法器的支持。而在时钟管理中，需要硬件计数器保持时钟的运行。进程调度由调度算法决定 CPU使用权，由操作系统实现，不需要硬件的支持。 当中断或异常发生时，通过硬件实现将运行在用户态的 CPU 立即转入核心态。中断发生时若被中断的是用户程序，则系统将从目态转入管态，在管态下进行中断的处理；若被中断的是低级中断，则仍然保持在管态，而用户程序只能在目态下运行，因此进入中断处理的程序只能是OS 程序。中断程序本身可能是用户程序，但是进入中断的处理程序一定是 OS 程序。 计算机通过硬件中断机制完成由用户态到核心态的转换。注意：中断处理程序是在核心态下执行的一些列用于处理中断的程序，不要误选。 大多数计算机操作系统的内核包括四个方面的内容，即时钟管理、中断机制、原语和系统控制的数据结构及处理，其中第 4 部分实际上是系统调用类的指令(广义指令)。 CPU处于核心态时，可以执行除了“访管”指令外的全部指令。因为已经处于核心态了，自然不需要执行“访管”指令。 特权指令指仅能由操作系统执行的指令。 系统调用是操作系统提供给用户程序的接口，系统调用发生在用户态，被调用程序在核心态下执行。 在某状态执行和在某状态发生是不同的，注意辨别。 trap 指令、跳转指令和压栈指令均可以在用户态执行，其中 trap 指令负责由用户态转换为内核态。关中断指令为特权指令，必须在核心态才能执行。 考虑到部分指令可能出现异常 (导致中断)，从而转到核心态。除法指令有除零异常的可能，软中断（软件异常）指令一定导致转到核心态，读写内存时可能出现缺页异常，导致转到核心态，寄存器取非等指令不会引发异常，故不会导致转到核心态。 缺页属于异常。 执行系统调用的顺序：①传递系统调用参数，②执行陷入（trap）指令，③执行相应的服务程序，④返回用户态 保存中断程序的中断点由硬件自动完成。 操作系统提供中断服务，初始化中断向量表，保存中断屏蔽字。 在内核态下，CPU 可执行任何指令，在用户态下 CPU 只能执行非特权指令，而特权指令只能在内核态下执行。常见的特权指令有: ①有关对 I&#x2F;0 设备操作的指令；②有关访问程序状态的指令；③存取特殊寄存器的指令；④其它指令。 发生中断时保存断点和状态字，模式改为内核态的操作都是由硬件完成的，保存通用寄存器内容，执行系统服务例程是由操作系统完成的。 处理器区分执行态（核心态和用户态）的主要目的是保护系统程序。用户态到核心态的转换发生在中断产生时，而核心态到用户态的转换则发生在中断返回用户程序时。 p030-1.6.2 操作系统的结构： 两类虚拟机管理系统的对比： 通常可以从四个方面来描述微内核OS：①内核足够小，②基于客户&#x2F;服务器模式，③应用“机制与策略分离”原理“，④采用面向对象技术。(红色为认知盲区处) 低级进程管理和调度属于调度功能的机制部分，应将它放入微内核。 微内核在核心态和用户态之间频繁切换，系统开销大，系统效率低。 微内核结构添加系统服务时不必修改内核。 由于微内核结构内的服务较少，因此系统更具有可靠性（稳定性）。 Windows是宏内核操作系统 操作系统的引导程序位于磁盘活动分区的引导扇区中。引导程序分为两种：一种是位于 ROM中的自举程序**(BIOS 的组成部分)，用于启动具体的设备；另一种是位于装有操作系统硬盘**的活动分区的引导扇区中的引导程序(称为启动管理器)，用于引导操作系统。 计算机启动的过程： 激活CPU：CPU加电，读取ROM中的boot程序，该程序能将指令寄存器置为BIOS的第一条指令。因此启动CPU后先访问主存的ROM部分，才跳到BIOS。 硬件自检：启动BIOS后先进行硬件自检。 加载带有操作系统的硬盘：BIOS开始读取Boot Sequence（启动顺序），把控制权交给启动顺序排在第一位的储存设备，然后CPU将该存储设备引导扇区的内容加载到内存中。 加载主引导记录（MBR）：能以特定的标识符区分引导硬盘和非引导硬盘，非引导则查找下一个设备。MBR的作用是告诉CPU去硬盘的哪个主分区去找操作系统。 扫描硬盘分区表，并加载硬盘活动分区：MBR包含硬盘分区表，分区表能标识活动分区和非活动分区，找到含有操作系统的分区（活动分区）后，开始加载活动分区，将控制权交给活动分区。 加载分区引导记录（PBR）：读取活动分区的第一个扇区，这个扇区成为分区引导记录，其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。 加载启动管理器。 加载操作系统。 虚拟机可以由硬件实现：软件能实现的功能也能由硬件实现。 虚拟机不能实现真正的并行，实现并行的是多核处理机。 在操作系统初始化的过程中需要创建中断向量表，以实现通电自检 POST，CPU 检测到中断信号后，根据中断号查询中断向量表，跳转到相应的中断处理程序。 第二章 进程与线程p046-2.1.8 线程是处理机调度的基本单位，包含CPU现场，可以独立执行程序。 线程没有自己独立的地址空间，它共享其所属进程的空间。 动态性是进程最重要的特性，以此来区分文件形式的静态程序。操作系统引入进程的概念是为了从变化的角度动态地分析和研究程序的执行。 进程的优先级分静态和动态两种，动态优先级是根据运行情况而随时调整的 进程获得处理器运行是通过调度得到的 在系统发生死锁时有可能进程全部都处于阻塞态，CPU 空闲。[坑] 例：在单一处理器系统中任何时刻都只有一个进程处于运行状态。（错） 程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响。也就是说，进程在执行过程中不管是不停顿地执行，还是走走停停，进程的执行速度都不会改变它的执行结果。失去封闭性后，不同速度下的执行结果不同。 进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，它包括 PCB、程序和数据以及执行栈区，仅仅说进程是在多程序环境下的完整程序是不合适的，因为程序是静态的，它以文件形式存放于计算机硬盘内，而进程是动态的。 C语言编写的程序在使用内存时一般分为三个段,它们一般是正文段(即代码和赋值数据段)、数据堆段和数据栈段。 二进制代码和常量存放在正文段； 动态分配的存储区在数据堆段； 临时使用的变量在数据栈段。 由此，我们可以确定全局赋值变量在正文段赋值数据段，未赋值的局部变量和实参传递在栈段，动态内存分配在堆段，常量在正文段，进程的优先级只能在 PCB 内。 一个进程是程序在一个数据集上的一次运行过程。运行于不同的数据集，将会形成不同的进程。 同一个系统进程（或线程）可以由系统调用的方法被不同的进程(或线程)多次使用，它们是同一个进程（或线程）。 PCB 内所含的数据结构内容，主要有四大类：进程标志信息、进程控制信息、进程资源信息、CPU 现场信息。 进程的就绪数目越多，争夺 CPU 的进程就越多，但只要就绪队列不为空，CPU 就总是可以调度进程运行，保持繁忙。这与就绪进程的数目没有关系，除非就绪队列为空，此时 CPU进入等待态，导致 CPU的效率下降。 同一进程中，线程的切换不会引起进程的切换。当从一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。 引入线程后处理器在既能在进程间切换也能在线程间切换。 引入线程是为了减少程序执行时的时空开销。并不会增加时空开销。 在无线程的系统中，进程是资源调度和并发执行的基本单位。在引入线程的系统中，进程退化为资源分配的基本单位，而线程代替了进程被操作系统调度，因而线程可以并发执行，不论是否为同一个进程的线程。 整个系统只有一个键盘，而且键盘输入是人的操作，速度比较慢，完全可以使用一个线程来处理整个系统的键盘输入。 线程被唤醒，是指线程等待结束后进入就绪态。只在极少数情况下会提高其优先级，但一般也不会提到最高。 数据库不能直接作为进程间的通信方式。 采用轮转调度算法时，如果进程中分别设置 100个用户级线程和 100个内核级线程，则前者的执行时间是后者的 100 倍，可以说在轮转调度算法中，内核级线程与用户级线程的效果完全不同。 在用户级线程中，系统感知不到线程的存在，调度的对象是进程，因此，跨进程的用户级线程调度需要内核参与。 用户级线程不需要内核的支持，与系统平台无关，对线程管理的代码是属于用户程序的一部分。 内核级线程的程序实体可以在内核态运行。 进程时间片用完，可降低其优先级以让其他进程被调度进入执行状态。 进程是资源分配的基本单位，线程是处理机调度的基本单位。进程的代码段、进程打开的文件、进程的全局变量等都是进程的资源，唯有进程中某线程的栈指针(包含在线程 TCB 中)是属于线程的，属于进程的资源可以共享，属于线程的栈指针是独享的，对其他线程透明。 同一进程的个线程共享进程的地址空间。 管道通信虽然是用共享文件来实现的，但该文件只能存在于内存中，与磁盘容量大小无关。通常被系统限制大小 进程对管道读写都可能造成堵塞。 管道通信可以多写一读（仅考试）。 临界资源是只允许一个进程读写的共享资源，进程间互斥读写。 即使是父子进程也不能同时使用同一临界资源。 父进程创建子进程时会为其分配虚拟地址空间，虽然父进程和子进程可以共享一部分资源，但不能共享虚拟地址空间。 执行一条命令或运行一个应用程序时，进程和程序之间形成一对一的关系。进程在执行过程中可以加载执行不同的应用程序，从而形成一对多的关系；以不同的参数或数据多次执行同一个应用程序时，形成多对一的关系;并发地执行不同的应用程序时，形成多对多的关系。 父进程创建子进程和主程序调用子程序的区别：父进程创建子进程后，父进程与子进程同时执行(并发)。主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序才开始执行。 在操作系统中，进程是竞争和分配计算机系统资源的基本单位。每个进程都有自己的独立地址空间。为了保证多个进程能够彼此互不干扰地共享物理内存，操作系统利用硬件地址机制对进程的地址空间进行了严格的保护，限制每个进程只能访问自己的地址空间。 多线程是指在一个程序中可以定义多个线程并同时运行它们，每个线程可以执行不同的任务。 多线程与多任务的区别：多任务是针对操作系统而言的，代表操作系统可以同时执行的程序个数；多线程是针对一个程序而言的，代表一个程序可以同时执行的线程个数，而每个线程可以完成不同的任务。 系统就绪态和运行态无进程的可能性： 系统无进程 进程均处于等待状态 进程处于死锁 支持进程状态变迁至少需要包括创建新进程原语、阻塞进程原语、唤醒进程原语、终止进程原语等操作。 p069-2.2.7 时间片轮换调度算法的主要目的是，使得多个交互的用户能够得到及时响应，使得用户以为“独占”计算机的使用，因此它并没有偏好，也不会对特殊进程做特殊服务。时间片轮转增加了系统开销,所以不会使得系统高效运转，吞吐量和周转时间均不如批处理。但其较快速的响应时间使得用户能够与计算机进行交互，改善了人机环境，满足用户需求。 在单处理机多进程系统中，进程什么时候占用处理器及决定占用时间的长短是由进程的特点和进程调度策略决定的。如进程是 CPU繁忙型还是 I&#x2F;O繁忙型、自身的优先级等但仅有这些特点是不够的，能否得到调度还取决于进程调度策略，若采用优先级调度算法，则进程的优先级才起作用。至于占用处理器运行时间的长短，则要看进程自身，若进程是I&#x2F;O 繁忙型运行过程中要频繁访问I&#x2F;O 端口，即可能会频繁放弃 CPU，所以占用CPU 的时间不会长，一放弃 CPU，则必须等待下次调度。若进程是 CPU 繁忙型，则一旦占有 CPU，就可能会运行很长时间，但运行时间还取决于进程调度策略，大部分情况下，交互式系统为改善用户的响应时间，大多数采用时间片轮转的算法，这种算法在进程占用 CPU达到一定时间后，会强制将其换下，以保证其他进程的CPU使用权。 先来先服务算法有利于CPU繁忙型的作业，而不利于I&#x2F;O繁忙型作业。 在选择进程调度算法时应考虑以下几个准则：①公平：确保每个进程获得合理的 CPU份额；②有效：使 CPU尽可能地忙碌；③响应时间：使交用户的响应时间尽可能短；④周转时间：使批处理用户等待输出的时间尽可能短；⑤吞吐量：使单位时间处理的进程数尽可能最多。 时间片轮换算法是绝对可抢占的 作业是从用户角度出发的，它由用户提交，以用户任务为单位；进程是从操作系统出发的，由系统生成，是操作系统的资源分配和独立运行的基本单位。 [粗心易错]：三道程序$J_1,J_2,J_3$，运行时间分别为$T_1,T_2,T_3$($T_1&lt;T_2&lt;T_3$)。则平均周转时间为：$(3T_1+2T_2+T_3)&#x2F;3$，括号内123顺序易写反，虽然$J_1$只执行了一次，但每个程序都经历了$T_1$。 分时系统中，响应时间与时间片和用户数成正比。 中断向量本身是用于存放中断服务例行程序的入口地址，因此中断向量地址就应是该入口地址的地址。 中断由硬件保护并完成，主要是为了保证系统运行可靠、正确。提高处理速度也是一个好处，但不是主要目的。 UNIX是分时操作系统。[补充]分时操作系统：WIndows,Unix,Linux；实时操作系统：uCOS-II,VxWorks；单用户操作系统：DOS。 当进程处于临界区时说明进程正在占用处理机，只要不破坏临界资源的使用规则，就不会影响处理机的调度。 对于优先级调度算法一般来说，IO 型作业的优先权高于计算型作业的优先权，这是由于 I&#x2F;O 操作需要及时完成，它没有办法长时间地保存所要输入&#x2F;输出的数据，所以考虑到系统资源利用率，要选择 I&#x2F;O 繁忙型作业有更高的优先级。 时钟中断是系统中特定的周期性时钟节拍，操作系统通过它来确定时间间隔，实现时间的延时和任务的超时。因此时钟中断发生后，系统会修改当前进程在时间片内的剩余时间。 时间片调度算法中，中断处理结束后，系统检测当前时间片是否用完，若用完则进程调度。 [粗心易错]：程序最开始执行的进程也应算入调度次数中，容易丢掉。 为什么说多级反馈队列调度算法能较好的满足各类用户的需要？ [易错]：计算利用率时，即使出现某资源在最后未出于使用状态，也要将该时间段计算入总时间。 对于多道作业的处理系统：有n道作业处理系统，则内存中能存放n个作业，内存有空位后由外部调度算法进行调度，调入后再由程序调度算法调入处理机。 调入内存后的时间才算作周转时间。 高相应比优先调度算法不抢占，一个程序执行完成后计算相应比，继续选择下一个要执行的程序。 对于多道作业批处理系统的题目，可以画出如下图更加直观，但只问周转时间也可只在表格后添加进出内存时间。 对于进程优先数priority，cpu占用时长cpuTime，等待时长waitTime，通过以下计算方法，可实现动态优先数，避免出现饥饿现象。（nice是进程本身优先级越小越优先，priority越小越优先）$priority&#x3D;nice+k_1cpuTime-k_2waitTime$。 p101-2.3.7 多个进程可以共享系统中的资源，一次仅允许一个进程使用的资源称为临界资源。访问临界资源的那段代码称为临界区。 磁盘属于共享设备，不是临界资源。 公用队列是公共使用，且一次只能有一个程序访问，因此是临界资源。 P、V操作是一种低级的进程通信原语，它是不能被中断的。 与互斥信号量初值一般置1不同，用PV操作实现进程同步时，信号量的初值应根据具体情况来确定。若期望的消息尚未产生，则对应的初值应设为 0:若期望的消息已存在，则信号量的初值应设为一个非0的正整数。故进程同步信号量的处置一般由用户确定。 若代码可被多个进程在任意时刻共享，则要求任意一个进程在调试此段代码时都以同样的方式运行；而且进程在运行过程中被中断后再继续执行，其执行结果不受影响。这要求代码不能被任何进程修改，否则无法满足共享的需求。这样的代码就是可重入代码，也称纯代码，即允许多个进程同时访问的代码。 一个系统中，由几个并发进程控制某一相同变量，临界区的数量为进程的数量。（因为临界区时访问临界资源的代码段） 管程由以下四部分组成： 管程的名称。 局部与管程内部的共享数据结构说明。 对该数据结构进行操作的一组过程 对局部于管程内部的共享数据设置初始值语句。 管程的signal操作与信号量机制中的V操作不同。信号量中V操作一定会改变信号量的值$S&#x3D;S+1$。而管程中的signal操作是针对某个条件变量的，若不存在因该条件而阻塞的进程，则signal不会产生任何影响。 [超级大坑][冲国特色傻逼抠字眼题目]题目问资源等待、运行的信号量条件时，一定要注意是操作前还是操作后。例如，信号量S**执行P操作后**，使该进程进入资源等待队列的条件和S执行P操作前的条件分别为 $S.value\\lt0$ 和 $S.value\\leq0$ ，请注意辨别。 [坑]系统中有 $n$ 个进程，则就绪队列中的进程数最多有 $n-1$ 个，不存在处理机为空，全在就绪队列的情况；阻塞队列中进程数最多有 $n$ 个，如果发生死锁，处理机可能为空，全部处于等待队列。 P，V属于两个原子操作，因此由两个不可被中断的过程组成。 忙则等待、空闲让进、有限等待是临界区互斥机制必须实现的，而让权等待则不一定非要实现。 &lt;—-整理未完成—-&gt;&lt;—-后面大题一天写一到二题，优先做真题—-&gt;p142-2.4.6&lt;—-整理未完成—-&gt;第三章 内存管理p174-3.1.8 内存保护是内存管理的一部分，是操作系统的任务，但是出于安全性和效率考虑，必须由硬件实现，所以需要操作系统和硬件机构的合作来完成。 下面几种装入方式的说明和执行时间。 静态装入：在编程阶段就把物理地址计算好。 可重定位：在装入时把逻辑地址转换成物理地址，但装入后不能改变。 动态重定位：在执行时再决定装入的地址并装入，装入后有可能会换出，所以同一个模块在内存中的物理地址是可能改变的。 动态重定位是指在作业运行过程中执行到一条访存指令时，再把逻辑地址转换为主存中的物理地址，实际中是通过硬件地址转换机制实现的。 分页式存储管理有内部碎片，分段式存储管理有外部碎片，固定分区存储管理方式有内部碎片，段页式存储管理方式有内部碎片。 多进程的执行通过内存保护实现互不干扰，如页式管理中有页地址越界保护，段式管理中有段地址越界保护。 页表和段表同样存储在内存中，系统提供给用户的物理地址空间为总空间大小减去页表或段表的长度。由于页表和段表的长度不能确定，所以提供给用户的物理地址空间大小也不能确定。 页表的功能由一组专门的存储器实现，其始址放在页表基址寄存器 (PTBR)中。这样才能满足在地址变换时能够较快地完成逻辑地址和物理地址之间的转换。 可重入程序主要是通过共享来使用同一块存储空间的，或通过动态链接的方式将所需的程序段映射到相关进程中去，其最大的优点是减少了对程序段的调入&#x2F;调出，因此减少了对换数量。 实现分页、分段和段页式存储管理需要特定的数据结构支持，如页表、段表等。为了提高性能，还需要硬件提供快存和地址加法器等，代价高。分区存储管理是满足多道程序设计的最简单的存储管理方案，特别适合嵌入式等微型设备。 内存管理是为了提高内存的利用率，引入覆盖和交换技术，即在较小的内存空间中采用重复使用的方法来节省存储空间，但它付出的代价是需要消耗更多的处理器时间，因此实际上是一种以时间换空间的技术。为此，从节省处理器时间上来讲，换入、换出速度越快，付出的时间代价就越小，反之就越大，当时间代价大到一定程度时，覆盖和交换技术就没有了意义。应以提高换入、换出速度为主要目标。 在非虚拟存储器中，作业必须全部装入内存且在运行过程中也一直驻留内存；在虚拟存储器中，作业不必全部装入内存且在运行过程中也不用一直驻留内存，这是虚拟存储器和非虚拟存储器的主要区别之一。 引入段式存储管理方式，主要是为了满足用户的下列要求：方便编程、分段共享、分段保护、动态链接和动态增长。 主存的访问，不是主存的分配。对主存的访问是以字节或字为单位的。例如，在页式管理中，不仅要知道块号，而且要知道页内偏移。 静态重定位是在程序运行之前由装配程序完成的，必须分配其要求的全部连续内存空间。而页式存储管理方案是将程序离散地分成若干页(块)，从而可以将程序装入不连续的内存空间，显然静态重定位不能满足其要求。 分区分配内存管理方式的主要保护措施是：界地址保护。 编译后的程序需要经过链接才能装载，而链接后形成的目标程序中的地址也就是逻辑地址。 最佳适应算法总是匹配与当前大小要求最接近的空闲分区，但是大多数情况下空闲分区的大小不可能完全和当前要求的大小相等，几乎每次分配内存都会产生很小的难以利用的内存块，所以最佳适应算法最容易产生最多的内存碎片。 &lt;–未总结完，D12需要看视频+大题未做非真题–&gt;p205-3.2.10 多次性、对换性和离散性是虚拟内存的特征，一次性则是传统存储系统的特征。 无论采用什么页面置换算法，每种页面第一次访问时不可能在内存中，必然发生缺页，所以缺页次数大于或等于 n。(n为程序页数量) 虚拟存储器的最大容量是由计算机的地址结构决定的，与主存容量和外存容量没有必然的联系。 页面失效（缺页）要计算第一次使用页面的次数。交换次数则不含第一次使用。 LRU算法需要对所有页最近一次被访问的时间进行记录，查找时间最久的进行替换，这涉及排序，对置换算法而言，开销太大。为此需要在页表项中增加LRU位，而需要硬件支持可以看作耗费高的结果，需要对所有页排序才是原因。 页表项中的合法位（存在位）信息显示本页面是否在内存中，即决定了是否会发生页面故障。 Belady异常是指：物理块数增大页故障却不减反增的现象，抖动不是Belady异常。 所有页面置换策略都可能引起抖动。 实地址是物理地址，即为物理内存实际的地址。虚地址是逻辑地址，是对用户来说的地址。程序页面大小计算时需要使用虚地址位数。 页表也有可能存储在磁盘的交换区上，可以通过让页表常驻内存来加快虚地址转换。 工作集即为最近窗口大小个页面序列的集合（记得去重）。 用户进程发起，请求操作系统的服务叫系统调用。页面置换过程由操作系统完成，不涉及系统调用；进程调度完全由操作系统完成，不涉及系统调用；创建进程可以通过系统调用来完成，如：Linux中通过fork系统调用来创建子进程；生成随机数只需要普通的函数调用，不涉及系统调用。 页置换算法会影响缺页率，例如，LRU 算法的缺页率通常要比 FIFO 算法的缺页率低。工作集的大小决定了分配给进程的物理块数，分配给进程的物理块数越多，缺页率就越低。进程的数量越多，对内存资源的竞争越激烈，每个进程被分配的物理块数越少，缺页率也就越高。页缓冲队列是将被淘汰的页面缓存下来，暂时不写回磁盘，**队列长度会影响页面置换的速度，但不会影响缺页率。 缺页发生页面置换后，会重新到快表中查找页表。置换后的页表会直接进入快表。 &lt;——部分题目未完成—–&gt;第四章 文件管理p240-4.1.8 打开文件操作是将FCB存入内存活跃文件目录表；找到指定文件目录是打开文件之前的操作。 目录文件是FCB的集合，一个目录中既可能有子目录，又可能有数据文件。因此目录文件中存放的是子目录和数据文件的信息。 文件目录项即FCB，通常由文件基本信息、存取控制信息和使用信息组成。基本信息包括文件物理位置。文件目录项显然不包括文件控制块(FCB)的物理位置。 用户访问权限是指用户有没有权限访问该文件，而用户优先级是指在多个用户同时请求该文件时应该先满足谁。文件的属性包括保存在FCB 中对文件访问的控制信息。因此对于一个文件的访问常由用户访问权限和文件属性共同限制。 相对于加密保护机制，访问控制机制的安全性较差。因为访问控制的级别和保护力度较小，因此它的灵活性相对较高。访问控制必须由系统实现，否则系统本身的安全性就无法保证。加密机制不能由系统实现，否则加密方法将无法扩展。 注册和登录属于系统级安全管理。 文件的逻辑结构：无结构文件（流式文件）和有结构文件。文件的物理结构：连续文件，链接文件。文件用途分类：系统文件和其它 对于由 $N$ 条记录的顺序文件，查找某关键字的记录时，平均要查找 $\\frac{N}{2}$ 次。在索引顺序文件中，最好情况时将 $N$ 条记录分为 $\\sqrt{N}$ 组，索引表中有 $\\sqrt{N}$ 个表项，每组有 $\\sqrt{N}$ 条记录，查找某关键字记录时，先顺序查找索引表，需要查找 $\\frac{\\sqrt{N}}{2}$ 次，然后在主文件中对应的组中顺序查找，也需要查找 $\\frac{\\sqrt{N}}{2}$ 次，因此共需查找 $\\frac{\\sqrt{N}}{2} + \\frac{\\sqrt{N}}{2} &#x3D; \\sqrt{N}$ 次。傻逼王道的课后题中出现了一种每次查找 $\\sqrt{N}+1$个的神奇现象，知道就好了不要当真，题目讲解的视频没这选项就nm离谱。 索引文件的表项中含有关键字和存放该记录的逻辑地址。易错，不是物理地址。逻辑索引和索引分配要分开。 打开文件表仅存放已打开文件信息，将指名文件的属性从外存复制到内存，再使用该文件时直接返回索引。位图和空闲盘块链表是磁盘管理方法。索引表中记录每个文件所存放的盘块地址。 若一个用户进程通过read系统调用读取一个磁盘文件中的数据： 当所读文件的数据不在内存时，产生中断(缺页中断)，原进程进入阻塞态，直到所需数据从外存调入内存后，才将该进程唤醒。 read 系统调用通过陷入将CPU从用户态切换到核心态，从而获取操作系统提供的服务。 要读一个文件，首先要用 open 系统调用打开该文件。 open 中的参数包含文件的路径名与文件名，而read 只需使用open 返回的文件描述符，并不使用文件名作为参数。 read 要求用户提供三个输入参数:①文件描述符 fd；②buf 缓冲区首址；③传送的字节数 n。 read 的功能是试图从fd所指示的文件中读入n个字节的数据，并将它们送至由指针 buf 所指示的缓冲区中。 若文件系统索引节点，索引节点总数与单个文件长度无关。 CD-ROM中视频文件的快速随机播放性能最好的数据块组织方式是连续结构，因为CD-ROM不能修改，且连续结构可以很好的快速的随机播放。 &lt;——大题未完成—–&gt;p258-4.2.7 实现用户对文件的按名存取，系统先利用用户提供的文件名形成检索路径，对目录进行检索。在顺序检索中，路径名的一个分量未找到，说明路径名中的某个目录或文件不存在，不需要继续检索。 目录的查询方式有两种:顺序检索法和 Hash 法，通常采用顺序检索法。 在树形目录中，为了加快文件检索速度，可设置当前目录，文件路径可以从当前目录开始查找。 在顺序检索法查找完成后，得到的是文件的逻辑地址。 文件在磁带上通常采用连续存放方法，在硬盘上通常不采用连续存放方法，在内存上采用随机存放方法。 对文件的访问控制，常由用户访问权限和文件属性共同限制。 在树形目录结构中，对于不同用户的文件，文件名可以不同也可以相同。 防止文件受损常采用备份的方法，而存取控制矩阵方法用于多用户之间的存取权限保护。 建立符号链接时，引用计数值直接复制；建立硬链接时，引用计数值加 1。删除文件时，删除操作对于符号链接是不可见的，这并不影响文件系统，当以后再通过符号链接访问时，发现文件不存在，直接删除符号链接；但对于硬链接则不可直接删除，引用计数值减 1，若值不为 0，则不能删除此文件，因为还有其他硬链接指向此文件。 符号链接创建后复制文件的引用计数值，且全程不再改变。 硬链接指通过索引结点进行链接。一个文件在物理存储器上有一个索引结点号。存在多个文件名指向同一个索引结点的情况。 两个进程各自维护自己的文件描述符，因此即使打开的是同一个文件，也是分别指向各自的文件表中的一项。 不同进程对同一个文件读写指针位置无关。 不同进程打开同一个文件： ①整个系统只有一个系统文件打开表，同一个文件打开多次，只需改变引用计数。 ②进程打开文件表关于同一个文件不一定相同，例如读写指针位置不一定相同。 [例]：文件系统采用两级目录的结构，主目录有10个子目录，每个子目录有10个目录项。在同样多目录的情况下，采用单级目录结构的平均检索目录项数是原来的 5 倍。两级目录检索 $\\frac{10}{2}+\\frac{10}{2}&#x3D;10$ 次。单级目录检索次数 $\\frac{10*10}{2}&#x3D;50$ 次。 p273-4.3.7 从系统角度看，文件系统负责对文件的存储空间进行组织、分配，负责文件的存储并对存入文件进行保护、检索。从用户角度看，文件系统根据一定的格式将用户的文件存放到文件存储器中适当的地方，当用户需要使用文件时，系统根据用户所给的文件名能够从文件存储器中找到所需要的文件。 即从用户观点看操作系统引入文件系统的目的是：实现文件的按名存取。 文件的存储空间管理实质上是对外存空闲区的组织和管理。 为了实现虚拟文件系统(VFS)，Linux 主要抽象了四种对象类型：超级块对象、索引结点对象、目录项对象和文件对象。 传统文件系统管理空闲磁盘的方法包括空闲表法、空闲链表法、位示图法和成组链接法。文件分配表(FAT)的表项与物理磁盘块一一对应，并且可以用一个特殊的数字-1表示文件的最后一块，用-2表示这个磁盘块是空闲的(当然也可用-3-4 来表示)，因此FAT 不仅记录了文件中各个块的先后链接关系，同时还标记了空闲的磁盘块，操作系统可以通过 FAT 对文件存储空间进行管理。 第五章 输入&#x2F;输出(I&#x2F;O)管理p282-5.1.6 共享设备指一段时间允许多个进程同时访问，不是同一时间。 共享设备必须是可寻址的和可随机读写的。 分配共享设备不会引起进程死锁。 不存在I&#x2F;O地址寄存器。地址寄存器只有计算机主机有。 为了便于上层软件的编制，设备控制器通常需要提供：控制寄存器、状态寄存器和控制指令。 通道也是用于实现内存与外设之间的信息传输。 命令&#x2F;状态寄存器控制DMA 的工作模式并给 CPU反映它当前的状态，地址寄存器存放DMA作业时的源地址和目标地址，数据寄存器存放要 DMA 转移的数据，只有堆指针寄存器不需要在DMA 控制器中存放。 字节多路通道，它通常含有许多非分配型子通道，其数量可达几十到几百个，每个通道连接一台 IO 设备，并控制该设备的 I&#x2F;O 操作。这些子通道按时间片轮转方式共享主通道。各个通道循环使用主通道，各个通道每次完成其 I&#x2F;O 设备的一个字节的交换，然后让出主通道的使用权。这样，只要字节多路通道扫描每个子通道的速率足够快，而连接到子通道上的设备的速率不太高时，便不至于丢失信息。故用于连接大量的低俗或中速I&#x2F;O设备。 设备的固有属性决定了设备的使用方式；设备独立性可以提高设备分配的灵活性和设备的利用率；设备安全性可以保证分配设备时不会导致永久阻塞。设备分配时一般不需要考虑及时性。 计算机系统为每台设备确定一个编号以便区分和识别设备，这个确定的编号称为设备的绝对号。 通道控制设备控制器，设备控制器控制设备工作。 通道是特殊的处理器，不是软件。 所有设备的启动工作都由系统统一来做 来自通道的I&#x2F;O中断事件由设备管理负责处理 编制好的通道程序是存放在主存中的 操作系统只需要按照类型提供驱动程序。例如：3台打印机2台绘图机只需要两个设备驱动程序。 系统调用是操作系统提供给用户程序的通用接口，属于设备无关软件的功能，不会因为具体设备的不同而改变。而设备驱动程序负责执行操作系统发出的 IO 命令，它因设备不同而不同。 键盘是典型的通过中断 I&#x2F;O 方式工作的外设，当用户输入信息时，计算机响应中断并通过中断处理程序获得输入信息。 I&#x2F;O软件一般从上到下分为 4 个层次：用户层、与设备无关的软件层、设备驱动程序及中断处理程序。与设备无关的软件层也就是系统调用的处理程序。 用户程序发出磁盘I&#x2F;O请求后，计算数据所在磁盘的柱面号、磁头号、扇区号的程序是：设备驱动程序。 设备的独立性主要是指用户使用设备的透明性，即使用户程序和实际使用的物理设备无关。 CPU 与IO 设备执行速度通常是不对等的，前者快、后者慢，通过高速缓冲技术来改善两者不匹配的问题。 缓冲池是系统的共用资源，可供多个进程共享，并且既能用于输入又能用于输出。其一般包含三种类型的缓冲①空闲缓冲区；②装满输入数据的缓冲区；③装满输出数据的缓冲区。为了管理上的方便，可将相同类型的缓冲区链成一个队列。 在鼠标移动时，若有高优先级的操作产生，为了记录鼠标活动的情况，必须使用缓冲技术。 由于磁盘驱动器和目标或源I&#x2F;O 设备间的吞吐量不同，必须采用缓冲技术。 为了能使数据从用户作业空间传送到磁盘或从磁盘传送到用户作业空间，必须采用缓冲技术。 为了便于多幅图形的存取及提高性能，缓冲技术是可以采用的，特别是在显示当前一幅图形又要得到下一幅图形时，应采用双缓冲技术。 在单机系统中，最关键的资源是处理器资源，最大化地提高处理器利用率，就是最大化地提高系统效率。多道程序设计技术是提高处理器利用率的关键技术。SPOOLing，虚拟技术，交换技术均为设备和内存的相关技术。 SPOOLing 技术需要使用磁盘空间(输入井和输出井)和内存空间(输入&#x2F;输出缓冲区)，不需要外围计算机的支持。 SPOOLing系统由预输入程序、井管理程序和缓冲输出程序组成。 因为SPOOLing 技术是一种典型的虚拟设备技术，它通过将独占设备虚拟成共享设备，使得多个进程共享一个独占设备，从而加快作业的执行速度，提高独占设备的利用率。既然是将独占设备虚拟成共享设备，所以必须先有独占设备才行。 独占设备采用静态分配方式，而共享设备采用动态分配方式。 SPOOLing技术设备与输入输出井之间的数据传送是由操作系统实现的，用户不能控制。 设备可视为特殊文件（Linux），因此可以使用文件名访问物理设备。 初始化设备是由驱动程序完成的。 厂家会根据设备特性，在驱动程序中实现一种最合适的IO控制方式，驱动程序和IO控制方式有关。 p310-5.3.6 固态硬盘部分总结 操作系统的引导程序位于磁盘活动分区的引导扇区，因此必然产生在分区之后。分区是将磁盘分为由一个或多个柱面组成的分区(即 C盘、D等形式，每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中。**而对于高级格式化(创建文件系统)**，操作系统将初始的文件系统数据结构存储到磁盘上。 磁盘调度算法是为了减少寻找时间。 扇区数据的处理时间主要影响传输时间。 绝大多数操作系统为改善磁盘访问时间，以簇为单位进行空间分配。 当系统总是持续出现某个磁道的访问请求时，均持续满足最短寻道时间优先、扫描算法和循环扫描算法的访问条件，会一直服务该访问请求。而先来先服务按照请求次序进行调度，比较公平。 "},{"title":"【错题本】考研-2024-计组错题本","date":"2023-12-23T06:32:25.000Z","url":"/subweb/blog/2023/12/23/0014.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E9%94%99%E9%A2%98%E6%9C%AC/","tags":[["研究生考试","/subweb/blog/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95/"],["计算机","/subweb/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"],["学习","/subweb/blog/tags/%E5%AD%A6%E4%B9%A0/"],["408","/subweb/blog/tags/408/"],["错题本","/subweb/blog/tags/%E9%94%99%E9%A2%98%E6%9C%AC/"],["计算机组成原理","/subweb/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"categories":[["学习","/subweb/blog/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"计算机组成原理错题本王道考研-2024-计算机组成原理考研复习指导第一章 计算机系统概述p008-1.2.6 冯诺伊曼机的基本工作方式是控制流驱动方式 多处理机的工作方式是多指令多数据流 相联存储器的特点：存储器按内容选择地址。相联存储器既可以按地址寻址，又可以按内容寻址，又称按内容寻址的存储器。 冯诺伊曼机的根本特征“存储程序”原理，微程序控制方式 CPU存取速度比较：寄存器&gt;Cache&gt;内存 系列机的基本特性是指令系统向后兼容 数据库系统不属于系统软件！数据库系统是在计算机系统种引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员构成。其中数据库管理系统是系统程序。[坑] 虽然指令和数据都以二进制形式存放在存储器中，但CPU可以根据指令周期的不同阶段来区分是指令还是数据，通常在取指阶段取出的是指令，在执行阶段取出的数据。CPU只有在确定取出的是指令后才会将其操作码送去译码，因此不能根据译码结果来区分指令和数据。 p015-1.3.3 存储体由许多存储单元组成，每个存储单元又包含若干存储元件，每个存储元件能寄存一位二进制代码“0”或“1”。可见，一个存储单元可存储一串二进制代码，称这串二进制代码为一个存储字，称这串二进制代码的位数为存储字长。 计算机的机器字长是指数据运算的基本单位长度 寄存器由D触发器构成 磁盘可以永久性存放数据和程序（仅408） 机器字长，指令字长，存储字长三者在数值上可能不等 数据字长：数据总线一次可以并行传输的位数，不一定等于MDR 机器字长是机器一次可以处理的二进制数据位数，因此决定着可处理二进制代码的位数 一台计算机的字长为n，则计算结果最大应为$2^n-1$，因为要将0算在内。 汇编程序员可以通过JMP指令来设置 PC（程序计数器） 的值。状态寄存器、通用寄存器只有为汇编程序员可见，才能实现编程，而IR（指令寄存器）、MAR（地址寄存器）、MDR（数据寄存器）是CPU的内部工作寄存器，对程序员均不可见。 CPI是&#x3D;&#x3D;执行一条指令所需的时钟周期数&#x3D;&#x3D;，系统结构、指令集、计算机组织都会影响CPI，但时钟频率不会影响CPI 兼容指计算机软件或硬件的通用性，通常在同一系列不同型号的计算机间通用。 计算机不同方面的应用 命令包括操作系统的命令（管态），应用程序的命令（目态），所以评价运算速度时不能只对一种进行评价。 机器字长是指CPU内部用于整数运算的数据通路的宽度。主要是CPU内部进行数据运算，存储和传送的不见，这些部件的宽度基本上要保持一致，因此，&#x3D;&#x3D;机器字长等于CPU内部用于整数运算的运算器（ALU）位数和通用寄存器宽度&#x3D;&#x3D;。 若给出主存容量为64K*32位：该主存有64K个存储单元，每个存储单元有32位。得出以下结论：（假设指令字长&#x3D;存储字长&#x3D;机器字长） 地址位数：$64K&#x3D;2^6*2^{10}&#x3D;2^{16}$，故地址位数16位。 存储字长：32位。 ACC，X，MDR，MQ：存储数据，且指令字长&#x3D;存储字长&#x3D;机器字长，故均为32位。 IR为指令寄存器且指令字长&#x3D;存储字长&#x3D;机器字长，故为32位。 MAR，PC用于存放地址，故为16位 数据通路： p018-03： &#x3D;&#x3D;总结&#x3D;&#x3D;：修改指令集后，可以先计算修改后程序的指令总数再算出比例，列出表格更直观 第二章 数据的表示和运算p030-2.1.5&lt;–未总结完部分–&gt;第三章 存储系统p081-3.1.4 相联存储器是按照内容指定方式和地址指定方式相结合的方式寻址的。 Cache命中率计算中，若要求存取时间不超过某时间时，计算结果应向上取。 能看到虚拟存储器中主存和辅存之间的数据调动。只对应用级程序员透明。 EPROM（可编程可擦除只读存储器），RAM类的ROM类的基本都能随机读写，CD-ROM是例外。 主存系统效率：$$主存系统效率&#x3D;\\frac{访问Cache的时间}{平均访问时间}$$ p89-3.2.5 SRAM芯片引脚除了地址线，数据线，电源和接地外，还需要1根RD（读控制线）和2根WE（写控制线）。 DRAM的刷新是以行为单位的 若一DRAM芯片采用地址复用技术，地址线减半，数据线不变，同时，需要两套读写控制线。[坑] 动态半导体存储器利用电容储存电荷记录信息，需要刷新，但刷新是在RAM上进行的，只进行了一次访存，因此完整的刷新过程只需要一个存储周期。 注意在体数的非整数倍的连续内存上读取数据时，多次读写的等待时间。可能未必需要一个存储周期就可以进行访问。如下题（ps:遇到该类型题目可参考下题答案画图解决） 程序的局部性原理：是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行访问的存储空间也局限于某个内存区域，具体来说，局部性通常有两种形式：时间局部性和空间局部性 时间局部性：被引用过一次的存储器位置会在未来被多次引用（通常在循环中）。 空间局部性：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。 由上条内容知：由于高位交叉存储器在单个存储器中的字时连续存放的，不满足程序的局部性原理；儿地位交叉存储器时交叉存放的，很好的满足了程序的局部性原理。 高位交叉存储器虽然不能满足程序的连续读取，但仍可能一次连续读出彼此地址相差一个存储体容量的几个字，只是这么读的概率较小 DRAM默认采用地址线复用技术，地址线为所得值的一半 SDRAM是现在常用的DRAM，也需要刷新才能保留数据，若题目中问到，则它被包含于DRAM，应当选DRAM。 DRAM缓冲大小为单个芯片一行的总位数。即8192*8192*8的DRAM芯片缓冲大小为8192*8位。 在显示器中，用于存放显示信息的存储器称为刷新存储器，要提高刷新存储器带宽，可采用以下技术：①采用告诉DRAM芯片；②采用多体交叉存储结构；③刷新存储器至显示器的内部总线宽度加倍；④采用双端口存储器将刷新端口和更新端口分开。 不一定在同一模块内访问间隔小于体数就会冲突，如果中间存在访问冲突，造成的延迟可能会使其不再发生冲突。 同时启动按顺序访问时，需要访问地址高位相同（每一轮启动的单元地址高位相同），如图： 访问途中阴影部分，需要三个周期，一次只能读同一行的内容。 若把存储器改成单体4字宽度带来的好处和问题？ 比较多体存储器和多端口存储器的优缺点？ p101-3.3.5 地址总线低位接入地址端，高位用于选片。 编址时，应当按照地址空间大小来计算MAR的位数，实际容量可能比地址空间大小更小，但它不能代表MAR的位数，因为考虑到存储器扩展的需要，MAR应保证能访问到整个主存空间。反过来，MAR的位数决定了主存地址空间的大小。 DRAM采用地址复用技术，只有行列相同时地址线才为原来的$\\frac{1}{2}$，且地址分行列两次传送。若DRAM有r行，c列，则地址引脚的个数为：$log_2(max{r,c})$。 DRAM刷新是按行刷新的，若需要减少刷新开销，应当减少行数。 说明地址线作用时，应具体指明那些地址线的工作和原因，如下例是由32个512K*8位的芯片组成的4M*32位的存储器的22根地址线的作用： DRAM刷新时按行刷新，刷新间隔内只需要考虑单个芯片的刷新即可，如一个DRAM芯片（64*64）刷新间隔不超过2ms，则刷新信号周期为：$\\frac{2ms}{64}&#x3D;0.03125ms$。无需考虑整个内存中的所有芯片。 画出CPU存储器连接结构图，CPU的接口有地址信号，数据信号和控制信号。 分配非2的整次方大小的存储时选择多种芯片，应当从大的选起，使所选芯片尽可能少。 p109-3.4.3 计算机械硬盘的读取所需时间种，其寻址时间是寻道时间加上旋转延迟（未指明则为硬盘转半圈的时长）。易错！。 磁盘条带化：指将一块连续的数据分成很多小部分，并把它们分别存储到不同磁盘上。这样进程在访问数据的时候，可以同时向多个不同部分同时发出I&#x2F;O请求，由于这些数据存放在不同的磁盘上，因而不会造成磁盘冲突，而且在需要对这种数据进行顺序访问的时候可以获得最大程度上的I&#x2F;O并行能力，从而获得非常好的性能。（RAID0）。 磁盘存储器的最小读写单位为一个扇区，即磁盘按块存取。 磁盘扇区种包含数据、地址和校验等信息。 在磁盘中，若长度超过一个磁道容量的文件，将它记录在同一个柱面上是比较合理的，因为不需要重新寻找磁道，这样数据读写速度快。 p119-3.5.6 各层次的存储系统不是孤立工作的，三级结构的存储系统是围绕主存储器来组织、管理和调度的从存储器系统，它们既是一个整体，又要遵循系统的运行原理，其中包括包含性原则。由于Cache种存放的是主存种某一部分信息的副本，所以不能认为总容量为两个层次容量的简单相加！！！[易错+重点] 一个块通常由若干字组成，CPU与Cache (或主存)间信息交互的单位是字，而Cache 与主存间信息交互的单位是块。 Cache为空时同样不可能命中，应计入失效率种 各种映射中，地址映射表的单个大小除了一致维护和替换算法位外，还需考虑一位的有效位。 **直接映射**中主存地址结构：（注意这是主存地址！不是Cache前面的标记） ​ 主存字块标记（标记）：$主存地址位数-Cache内地址位数$，表示主存大小是Cache大小的多少倍，倍数的二进制表示的位数。用于存储该可表示该块Cache是主存上哪一大块的。可以看作将主存分为和Cache相等的n大块，这是第几大块上的数据。 ​ Cache字块地址（Cache行号）：$Cache地址位数-每块块内地址位数$。非标记部分，仅用于查找。他能表明当前主存块应当存在Cache的哪一个块上。 ​ 字块内地址（块内地址）：对应的大小是主存的字长，所以一般用块的总大小（bit）除以主存的字长得到的值位数。 **全相联映射**中主存地址结构：（注意这是主存地址！不是Cache前面的标记） ​ 标记：用于标记该块在主存的具体位置，因为全相联并不具有位置规律，所以除了块内地址外全部都是标识。其中末尾n位可作为块号，n是Cache块的个数所占位数。块号和后面的块内地址连起来（相连接，不是相加）是对应Cache的字地址（按字编址的地址）。 ​ 块内地址：块内地址记录要查的内存在Cache块内的位置。$块内地址总数&#x3D;块内数据宽度（bit）&#x2F;主存字长（bit）$,由此可得出对应宽度。需要注意，主存字长和Cache字长未必相等，因此这里比较的是数据宽度。 **组相联映射**中主存地址结构：（注意这是主存地址！不是Cache前面的标记）（n路组相联是指一组由n个块，不是有n个组） ​ 标记：实际作用同直接映射，位数可以通过公式算出，也可用总位数减去Cache组号位数和块内地址位数算出。 ​ Cache组号：$Cache组号&#x3D;主存块号 mod Cache组数$，该部分位数位组数的二进制位数。 ​ 块内地址：块内地址记录要查的内存在Cache块内的位置。$块内地址总数&#x3D;块内数据宽度（bit）&#x2F;主存字长（bit）$,由此可得出对应宽度。需要注意，主存字长和Cache字长未必相等，因此这里比较的是数据宽度。 ​ 标记和Cache组成主存块号：一同组成了主存块号，该地址指定Cache上数据是主存中哪一大块的相同位置的数据。 CPU访问存储体系（Cache+内存+硬盘）时，发送的地址一定是主存物理地址。不会发送Cache地址，因为主存地址可以直接用于匹配Cache块。 逻辑地址、逻辑空间，即虚拟地址，虚拟空间。 对于虚拟存储器，一般主存的页（块）和虚拟存储的页一样大。 无论是物理地址还是虚拟地址，都有$物理&#x2F;虚拟地址&#x3D;物理&#x2F;虚拟页号+页内地址$。 【题目：p120.14】难度：⭐⭐⭐ 总结：一个数据指总线宽度的字长，每次读取对应字长的数据都需要发送地址和读命令，存储器也是每次都需要准备数据。 补充：由下面15题知道：部分存储器支持突发传送，可以连续的传输n个数据，因此n个数据传输需要n个总线传输市场，但仅需要1个发送地址和读命令的时长和1个准备数据的时长即可 第多少号储存单元就是第多少个地址，看清编址大小。由此可以推出对应的内存地址。 把指令Cache与数据Cache分离后，取指和取数分别到不同的Cache中寻找，则流水线中取指令部分和取数部分就可以很好的避免冲突，即减少了流水线的冲突。 a = a + 1;中，对a访问了2次，而不是一次，第一次访问若未命中则调入Cache中，第二次访问就会命中。[坑] 时间局部性：一旦一条指令执行，它就可能在不久的将来再被执行。空间局部性：一旦一个存储单元被访问，它附近的存储单月也很快被访问。 组相联映射CPU访存，先根据地址中间的组号找到对应的组，然后将对应Cache组中的每个行的标记与主存地址的高位（标记位）进行比较，若有一个相等且有效位为1则命中，否则不命中。 由上得知：组相联映射Cache中比较器有以下特点： Cache块内有m个主存字长的数据段，则需要m个比较器（一块能存几个内存字长的数据）。 标志位的宽度为n，则需要n位比较器。 &lt;–8,9两题存在超纲内容，一轮复习结束后写–&gt;&lt;–虚拟内存需学完操作系统后可做–&gt;第四章 指令系统p149-4.1.4 PC存放当前欲执行指令的地址，而指令的地址码字段保存操作数的地址，易混淆，CPU在执行指令的过程中指令的地址由PC给出 Tips：堆栈指令的访存次数，取决于采用的是软堆栈还是硬堆栈。若是软堆栈（对栈区由内存实现），则对于双目运算需要访问4次内存：取指、取原数1、取原数2、存结果。若是硬堆栈（堆栈区由寄存器实现），则只需在取指令时访问一次内存。 单字长的指令可以加快读取指令的速度。 但地址指令中只有一个地址码，在完成两个操作数的算数运算时，一个操作数由地址码指出，另一个操作数通常存放在累加寄存器（ACC）中，属于隐含寻址。 来看看GPT对寻址的介绍 直接寻址（Direct Addressing）：直接寻址是一种常见的寻址模式，其中指令中包含了要访问的操作数的内存地址。指令直接指定了要读取或写入数据的存储器位置。 立即寻址（Immediate Addressing）：立即寻址是一种寻址模式，其中指令本身包含了要使用的立即值（常量）。这个立即值通常被用作算术运算、逻辑运算或条件判断的操作数，而不需要从内存中加载。 隐含寻址（Implied Addressing）：隐含寻址是一种简化的寻址模式，其中指令没有显式指定操作数的位置或地址。相反，该指令已经约定好了要操作的特定寄存器或内存位置。这种寻址模式通常用于某些特定的操作或指令，例如清除寄存器或跳转指令。 间接寻址（Indirect Addressing）：间接寻址是一种寻址模式，其中指令中给出了一个内存地址，该地址指向另一个内存位置，而实际的数据则存储在这个间接指向的位置中。通过间接寻址，可以通过在内存中使用指针或索引来访问数据。 基址寻址（Base Addressing）：基址寻址是一种寻址模式，其中指令中给出了一个基址寄存器和一个偏移量。基址寄存器包含着一个内存地址，而偏移量表示相对于该基址的位移量。通过将基址和偏移量相加，可以计算出实际的内存地址，并从该地址读取或写入数据。 每种寻址模式都有其适用的场景和优势，编程语言和计算机架构通常支持多种寻址模式，以提供更灵活和高效的编程方式。 在指令格式中，采用扩展操作码设计方案的目的时：保持指令长度不变而增加指令的数量。 计算指令最短长度时，记得按字节编址。如计算出最短23位，则实际指令字长需要24位。需要为字的整数倍。 若题目未说明采用扩展操作码指令格式，则不使用。如下题所示 【题目：p151.1】难度：⭐⭐ 总结：对于这种题，尝试变长指令，所有指令的占位数都由操作码位数和地址位数组成，应将其相加。 采用扩展操作码，若n地址的指令数小于等于n+1地址指令所留下的可分配指令数，则分配到该空间，剩余操作数位置补0。 p159-4.2.3 采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性。但这也提高了指令译码的复杂度。 程序控制是靠转移指令而非寻址方式实现的。 为了缩短指令中某个地址段的位数，有效的方法是采用寄存器寻址：因为CPU中寄存器的数量通常不会太多，用很短的编码就能指定寄存器。 简化地址结构的基本方法是尽量采用隐地址：隐地址不给出明显的操作数地址，而是在指令中隐含 操作数的地址，因此可以简化地址结构，如零地址指令。 指令寻址的各种方式中，**立即寻址最快，指令直接给出操作数；寄存器寻址次之，只需要访问一次寄存器；直接寻址再次之，访问一次内存；间接寻址最慢**，要访问内存两次以上。 多道程序设计中，相对寻址尤为重要。相对寻址编址的程序无须指定绝对地址，只需确定程序内部的相对距离，从而可实现浮动地址，给程序的重定位带来了方便。便于实现多道程序。 跳跃寻址通过转移类指令（如相对寻址）来实现，可用来实现程序的条件或无条件转移。 转移指令、子程序与返回指令用于解决变动程序中指令执行次序的需求，而不是数据调用次序的需求。 寻址方式中，寄存器寻址的地址码最短，立即寻址的地址码最长。 采用寄存器寻址时执行速度最快，因为寄存器位于CPU内部，无需到内存读取操作数。立即寻址虽然无需读取操作数，但因取指令访问花费的时间较多，故没有寄存器寻址块。 编址寻址的寻址范围应该是Rx寄存器的寻址范围+形式地址（偏移量的寻址范围）。可以省略小的一部分。 无符号整数比较大小的判断不需要OF位，因此表达式中是否有OF可作为判断是否为有符号整数比较的依据。 仔细阅读题目，题目可能修改了寻址方式的部分细节。 ​ &lt;–9,10两题存在超纲内容，一轮复习结束后写–&gt;p182-4.3.5 P为调用过程，Q为被调用过程，在32位x86处理器上执行，过程调用所涉及的操作： 过程P将实参存放到Q能访问到的地方。 过程P将返回地址存放到待定处，并跳到Q执行。 过程Q保存P的现场，并为非静态局部变量分配空间。 执行过程Q的函数体。 过程Q回复P的现场，并释放局部变量所占空间。 过程Q取出返回地址，并跳转到过程P执行。 判断指令集是CISC或RISC，可优先从指令长度入手，若指令长度不同，则为CISC，其次，可以从寻址方式入手，RISC只允许load和store指令读写内存。 整数类型只要机器数不包含最高有效位则可通过整体左移（右移）的方式实现乘2（除以2）。而浮点数类型不可以，因为浮点数的数据中包含了阶码部分，不能通过整体移动实现。因此，浮点数的乘2（除以2）不能使用shl指令实现，其运算比整型运算要复杂，耗时也更长。 ret指令是程序的返回指令，也会使程序跳转执行，是无条件跳转指令中容易忽略的一种。[易错] 若整型计算结果数值已经超过计算机字长能表示的最大值，可以使用浮点型损失部分精度以获得正确结果。也可转换为long long?? 在整数乘法指令imul中，若乘积的高33位为非全0或非全1，则OF&#x3D;1。编译器应在imul指令后加一条“溢出自陷”指令，使CPU自动查询溢出标志OF，当OF&#x3D;1时，调出”溢出异常处理程序“。 p188-4.4.4 RISC一定采用流水技术，CISC可以使用流水技术。 CISC兼容性上比RISC好，CISC可以兼容很多老机器。 RISC选择一些常用的寄存器型指令，并不是为了兼容CISC，RISC也不可能加绒CISC。 RISC只是CPU结构发生变化，基本不影响整个计算机的结构，并且即使采用RISC的CPU，其架构也不可能像早期一样简单。 RISC的指令功能简单，通过简单指令的组合来实现复杂的指令的功能，并没有怎加每条指令的功能。 RISC指令长度一致、按边界对齐存放、仅Load&#x2F;Store指令访存，它们使取指令、取操作数的操作简化且时间长度固定，能够有效地简化流水线的复杂度。 第五章 中央处理器p193-5.1.3 数据总线的位数与处理器的位数相同，它表示CPU一次能处理的数据的位数，即CPU的位数。 转移指令时，不能说PC的值总修改为转移指令的目的地址，因为有可能使条件转移，只有在条件成立的情况下才修改PC寄存器的值。 程序计数器的位数取决于存储器的容量：因为内容为指令在主存中的地址，所以应与存储器地址的位数相等。 指令寄存器的位数取决于指令字长：指令寄存器保存当前正在执行的指令，所以其位数取决于指令字长。 CPU中通用寄存器的位数取决于机器字长：通用寄存器用于存放操作数和各种地址信息等，其位数与机器字长相等，便于操作控制。 通用寄存器供用户自由编程，可以存放数据和地址。而指令寄存器是专门用于存放指令的专用寄存器，不能由通用寄存器代替。 程序状态字寄存器用于保留算数、逻辑运算及测试指令的结果状态。 地址译码器是主存等存储器的组成部分，不是CPU的组成部分。 间址周期的作用是取操作数的有效地址，因此间址周期结束后，MDR中的内容为操作数地址。 CPU中的专用寄存器有：程序计数器(PC)、指令寄存器(IR)、存储器数据寄存器(MDR)、存储器地址寄存器(MAR)和程序状态字寄存器(PSW)。 p200-5.2.4 CPU从主存中每取出并执行一条指令所需的全部时间成为指令周期。 时钟周期通常成为节拍或T周期，它是CPU操作的最基本单位。 CPU周期也称机器周期，一个机器周期包含若干个时钟周期。 存取周期是指存储器进行两次独立的存储器操作（连续两次读或写操作）所需的最小间隔时间。 取指操作是自动进行的，控制器不需要得到相应的指令。 取指周期是取指令字。 由于CPU内部操作速度较快，而CPU访问一次存储器的时间较长，因此机器周期通常由存取周期来确定。 通常把通过一次总线事务访问一次主存或I&#x2F;O的时间定位一个机器周期。 执行各条指令的机器周期数可变，各机器周期的长度可变：机器周期是指令执行中每步操作(如取指令、存储器读、存储器写等) 所需要的时间，每个机器周期内的节拍数可以不等，因此其长度可变。因为各种指令的功能不同，所以各指令执行时所需的机器周期数是可变的。 CPU相应中断的时间是：一条指令执行结束，而不是指令周期结束，因为终端周期也属于指令周期。 存储器本身无法区分存储单元中存放的是指令还是数据。而是在控制单元的控制下，计算机在不同的阶段对存储器进行读写操作时去除的代码有不同的用处。在取指阶段读出的为指令，执行阶段读出的则可能为数据。其它部件均不能区分。 指令字长一般都取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要两次访存取指周期等于机器周期的 2 倍:若指令字长等于存储字长，则取指周期等于机器周期。 指令字长一般取字节或存储字长的整数倍，而不一定都和存储字长一样大。 p205-5.3.3 在单总线CPU中，ALU只有一个输入端与总线连接，另一输入端和输出端需要通过寄存器与总线连接。 是否采用CPU内部总线的数据通路的特点： 采用CPU内部总线方式的数据通路的特点：结构简单、实现容易、性能较低、存在较多的冲突现象； 不采用CPU内部总线方式的数据通路的特点：结构复杂、硬件量大、不易实现、性能高、基本不存在数据冲突现象。 单周期处理器是指所有指令的指令周期为一个时钟周期的处理器，故： 每条指令的 CPI为1， 要考虑比较慢的指令，所以处理器的时钟频率较低。 单总线数据通路将所有寄存器的输入输出端都连接在一条公共通路上，一个时钟内只允许一次操作，无法完成指令的所有操作。 控制信号是 CU 根据指操作码发出的信号，对于单周期处理器来说，每条指令的执行只有一个时钟周期，而在一个时钟周期内控制信号并不会变化。若是多周期处理器，则指令的执行需要多个时钟周期，在每个时钟周期控制器会发出不同信号。 指令执行过程中数据所经过的路径，包括路径上的部件，称为数据通路。ALU、通用寄存器状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑等，都是指令执行过程中数据流经的部件，都属于数据通路的一部分。数据通路中的数据流动路径由控制部件控制，控制部件根据每条指令功能的不同，生成对数据通路的控制信号。 &lt;–大题部分有时间再写–&gt;p226-5.4.4 CU 的输入信号来源如下: ①经指令译码器译码产生的指令信息; ②时序系统产生的机器周期信号和节拍信号;③来自执行单元的反馈信息即标志。前两者是主要因素。 微指令计数器决定的是微指令的执行顺序，而不是指令的执行顺序。 一条微指令存放在控制器的一个控制存储单元中。 微程序控制器的时序系统比较简单，因为它只需按照节拍的安排，顺序执行微指令。而硬件布线控制器需要结合各微操作的节拍安排，综合分析，写出逻辑表达式，再设计成逻辑电路图。因此时序系统比较复杂。 在微程序控制器中，控制部件向执行部件发出的控制信号称为微命令，微命令执行的操作称为微操作。微指令则是若干微命令的集合，若干微指令的有序集合称为微程序。 一组实现一定功能的微命令的组合构成一条微指令，有序的微指令序列构成一段微程序，微程序的作用是实现一条对应的机器指令。 兼容性微命令是指那些可以同时产生、共同完成某些微操作的微命令。 指令周期是从一条指令启动到下一条指令启动的间隔时间，而 CPU 周期是机器周期，是指令执行中每步操作所需的时间。 在采用微程序控制器的 CPU 中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令。故一个微程序的周期对应一个指令周期。 CPU 控制器主要由三个部件组成: 指令寄存器、程序计数器和操作控制器。 状态条件寄存器通常属于运算器的部件，保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容，如运算结果进位标志(C)、运算结果溢出标志 (V) 等。 运算器、存储器、外围设备相对控制器来说就是执行部件。 不论主存储器（MM）或控制存储器（CS）都按地址访问。MM存储指令和数据，CS存储微指令，MM在CPU外，CS在CPU内。MM用RAM和ROM实现，CS用ROM实现。 CPU时钟脉冲信号以相邻状态单元间组合逻辑电路的最大延迟为基准确定。 只有在理想情况下的流水线 CPU 中，才可能实现每个时钟周期开始执行一条新指令，故不能说总是开始执行一条新的指令。 汇编程序员可见的寄存器有基址寄存器(用于实现多道程序设计或者编制浮动程序)和状态标志寄存器、程序计数器PC及通用寄存器组；而MAR、MDR、IR是CPU的内部工作寄存器对汇编程序员不可见。微指令寄存器属于微程序控制器的组成部分，它是硬件设计者的任务，对汇编程序员是透明的(不可见的)。 即使是控制存储器（CM）的容量也要求是2的整数次幂，如计算得出241条指令，那么CM容量应该为 $256*指令字长$。 &lt;–5.5节暂未讲解不知道傻逼王道搞什么–&gt;p244-5.6.6p258-5.7.4第六章 总线p267-6.1.6p274-6.2.4第七章 输入&#x2F;输出系统p280-7.1.4p284-7.2.5p293-7.3.42017.43 IEEE754浮点数阶码全1，位数全0表示无穷 "},{"title":"【错题本】考研-2024-数据结构错题本","date":"2023-12-23T06:31:25.000Z","url":"/subweb/blog/2023/12/23/0013.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%94%99%E9%A2%98%E6%9C%AC/","tags":[["研究生考试","/subweb/blog/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95/"],["计算机","/subweb/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"],["学习","/subweb/blog/tags/%E5%AD%A6%E4%B9%A0/"],["408","/subweb/blog/tags/408/"],["数据结构","/subweb/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"],["错题本","/subweb/blog/tags/%E9%94%99%E9%A2%98%E6%9C%AC/"]],"categories":[["学习","/subweb/blog/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"数据结构错题本王道考研-2024-数据结构考研复习指导p017.08[交换两数组问题]已知在一维数组$A[m+n]$中以此存放两个线性表$(a_1,a_2,a_3,…,a_m)$和$(b_1,b_2,b_3,…,b_n)$。编写一个函数，将数组中两个顺序表的位置互换，即将$(b_1,b_2,b_3,…,b_n)$放到$(a_1,a_2,a_3,…,a_m)$的前面。 算法思想：先将数组$A[m+n]$中的全部元素$(a_1,a_2,a_3,…,a_m,b_1,b_2,b_3,…,b_n)$原地逆置为$(b_n,b_{n-1},…,b_1,a_m,a_{m-1},…,a_1)$，再对前n个元素和后m个元素分别使用逆置算法，即可得到$(b_1,b_2,b_3,…,b_n,a_1,a_2,a_3,…,a_m)$，从而实现顺序表的位置互换。 tips：实际上是离散数学的德摩根定理，设原序列为AB，想要得到的序列为BA，则AB逆置，即$(AB)^{-1}&#x3D;B^{-1}A^{-1}$，因此再次对$B^{-1}$和$A^{-1}$进行逆置运算，得到BA &#x3D;&#x3D;本题代码如下：&#x3D;&#x3D; p017.10[数组元素移动问题] 分析：此题目其实和上面的第八题如出一辙，都是讲一部分换到另一部分，可以使用相同的办法，输入输出稍加改动即可 标准答案： p017.11[找两升序序列中位数] 分析：本题目所给两数组为升序，因此可以采用中位舍弃法（最佳答案），也可以双指针遍历法。双指针法也可以得到12分 标准答案： p017.12[找过半主元素][难点] 分析：解法一（最优）：若元素在数组中的个数超过一般，则可以看作一定有连续的存在，故可以通过和其他元素消去的办法，最终数量仍然大于0。解法二（一般）：因为题目已知$0\\leq a_i \\lt n (0\\leq i\\lt n)$，因此该整数学列是有限个的，创建一个大小为n的整数数组，依次遍历目标数组，遍历到的值为下标的计数数组的值加一。最后再遍历一遍计数数组，最大的值如果超过数组长度的一半则为主元素，否则无主元素 总结部分1.考研综合题给分方式： 考研常见设计思想，程序实现，复杂度分析经典三段式，这种题型实际答案并不唯一，不需要和答案完全相同（&#x3D;&#x3D;包括算法&#x3D;&#x3D;），算法不同，只要第三问分析正确，第三问不扣分。复杂度升高通常前两问同时扣分，按照升高的大小扣1-2分，因此，除非专业课要考满分（我），否则无需对答案的完美方法斤斤计较。 "},{"title":"【大模型问答】蓝光光盘中的PV,Teaser,Menu,IV,CM,Character PV分别指什么？-GPT3.5","date":"2023-04-04T07:31:36.000Z","url":"/subweb/blog/2023/04/04/0011.%E8%93%9D%E5%85%89%E5%85%89%E7%9B%98%E4%B8%AD%E7%9A%84PV,Teaser,Menu,IV,CM,Character%20PV%E5%88%86%E5%88%AB%E6%8C%87%E4%BB%80%E4%B9%88/","tags":[["GPT","/subweb/blog/tags/GPT/"],["影视","/subweb/blog/tags/%E5%BD%B1%E8%A7%86/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"蓝光光盘中的PV, Teaser, Menu, IV, CM, Character PV分别指以下内容： PV（Promotional Video）：这是一种用于宣传目的的视频，通常用于预告电影、动画、游戏等媒体作品。在蓝光光盘中，PV通常是该作品的预告片或广告片。 Teaser（预告片）：这是一种短暂而引人注目的视频片段，用于提前宣传即将发行的电影、剧集或游戏等作品。Teaser通常为全新作品的首个预告片，以引起观众的兴趣和好奇心。 Menu（菜单）：这是蓝光光盘中的交互式界面，类似于DVD上的菜单。菜单可以包括选项如“开始播放”、“选择章节”、“设置”等，并提供用户导航和控制光盘内容的功能。 IV（Image Video）：这是一种图像视频，在蓝光光盘中通常用于展示与作品相关的插图、画廊、幕后花絮、特写镜头等额外内容。IV提供了更多的视觉展示，增强了用户对作品的理解和欣赏。 CM（Commercial Message）：这指的是商业广告片，在蓝光光盘中通常包括与作品相关的广告。这些广告可能是为了其他相关产品、服务或合作伙伴而制作，以在光盘播放期间向观众展示。 Character PV（角色PV）：这是一种特殊类型的PV，用于突出作品中的角色。Character PV通常以某个主要角色为重点，通过短片或特别预告片来展示该角色的特点、背景故事或魅力，以吸引观众对角色的关注。 "},{"title":"【大模型问答】vulkan，openGL，DX等图形接口-GPT3.5","date":"2023-04-03T07:31:36.000Z","url":"/subweb/blog/2023/04/03/0010.vulkan%EF%BC%8CopenGL%EF%BC%8CDX%E7%AD%89%E5%9B%BE%E5%BD%A2%E6%8E%A5%E5%8F%A3/","tags":[["GPT","/subweb/blog/tags/GPT/"],["编程","/subweb/blog/tags/%E7%BC%96%E7%A8%8B/"],["图形接口","/subweb/blog/tags/%E5%9B%BE%E5%BD%A2%E6%8E%A5%E5%8F%A3/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"Vulkan,OpenGL,DirectX对比Vulkan，OpenGL和DirectX（DX）是常用的图形接口，被广泛用于游戏和图形应用开发。它们都有各自的特点和优势，因此很难一概而论哪个接口性能更强。 下面是对每个接口的简要介绍： Vulkan：Vulkan是一个跨平台的低级别图形和计算API。它提供了更直接的硬件访问和更多的控制权，允许开发人员更好地利用GPU的性能。Vulkan使用异步、并行的方式工作，并且对多线程处理有很好的支持。由于其底层性质，Vulkan通常在需要高度优化和对设备资源需求较大的场景下表现出色，例如使用大规模渲染技术或进行复杂的计算。 OpenGL：OpenGL是一个跨平台的图形API，广泛用于实时渲染和图形应用程序开发。它具有较高的稳定性和兼容性，并且易于学习和使用。然而，由于OpenGL的设计较早，它在性能方面可能不如Vulkan或DirectX。尽管如此，许多游戏和应用程序仍然使用OpenGL，并且在某些情况下，它可以提供足够的性能来满足需求。 DirectX（包括DirectX 11和DirectX 12）：DirectX是由Microsoft开发的一组技术，用于Windows平台上的多媒体和游戏开发。DirectX在Windows系统上提供了广泛的功能和工具，可以方便地进行图形和多媒体编程。DirectX 12是最新版本，引入了更低级别的API设计，类似于Vulkan，并且对多线程和并行处理有更好的支持。DirectX通常在Windows平台上具有较好的性能，尤其是在与硬件紧密合作并使用专门优化的驱动程序时。 要确定哪个接口具有更强大的性能，需要考虑许多因素，如应用程序的性质、目标平台、硬件配置以及开发人员的熟练程度。在实际应用中，根据具体需求选择适合的接口和技术是很重要的。 除了vulkan，openGL，DX以外，还有哪些高性能的图形接口除了Vulkan、OpenGL和DirectX，还有一些其他高性能的图形接口可供选择。以下是其中几个常用的选项： Metal：由苹果公司开发的图形接口，专为iOS和macOS系统设计，具有低延迟和高效能的特点。 WebGPU：Web浏览器中的图形编程接口，旨在提供与现代图形硬件更直接的交互，实现高性能的Web图形渲染。 DirectX 12 Ultimate：微软最新版本的图形API，提供对Windows平台上最新的图形硬件特性的支持，具有高度优化的性能和功能。 CUDA：由NVIDIA开发的并行计算平台和编程模型，主要用于利用NVIDIA GPU进行高性能计算和图形处理。 OpenCL：跨平台的并行计算框架，支持多种处理器架构，包括CPU、GPU和FPGA等，用于实现高性能通用计算任务。 WebGL：基于Web标准的图形接口，允许在Web浏览器中使用JavaScript进行硬件加速的3D图形渲染。 这些接口都具有不同的特点和适用范围，开发者可以根据具体需求选择最适合自己项目的图形接口。 QT是否属于图形接口是的，QT（跨平台应用程序和用户界面开发框架）是一种图形接口。它提供了一套功能强大的工具和库，用于创建各种类型的图形用户界面（GUI）应用程序。QT具有丰富的图形控件、布局管理器、绘图功能以及事件处理等特性，使开发人员能够轻松构建现代化、可交互的应用程序界面。同时，QT也提供了对不同操作系统的支持，包括Windows、macOS、Linux等，使开发者能够编写一次代码，然后在多个平台上运行其应用程序。 除了QT外，还有哪些高性能图形接口适合制作图形化界面除了QT外，还有一些其他高性能图形接口适合制作图形化界面的选择。以下是几个常用的选项： WxWidgets：WxWidgets 是一个跨平台的 C++ 图形用户界面库，它提供了类似于QT的开发体验。它支持多种操作系统，包括Windows、macOS和Linux等。WxWidgets具有良好的性能和丰富的控件库，可以用于开发图形化界面应用程序。 **GTK+**：GTK+ 是一个跨平台的图形用户界面工具包，使用C语言编写，但也支持其他编程语言如C++、Python等。它是GNOME桌面环境的标准工具包，支持多种操作系统。GTK+有很好的性能和可扩展性，并提供了丰富的控件库和主题支持。 JavaFX：JavaFX 是Java平台上专为创建富客户端应用程序设计的图形库。它提供了丰富的控件库、动画效果和多媒体功能。JavaFX的性能良好，并且与Java紧密集成，适用于开发Java应用程序的图形界面。 Electron：Electron 是一个基于Web技术（HTML、CSS、JavaScript）的桌面应用程序开发框架。使用Electron，您可以使用Web技术开发跨平台的图形界面应用程序。它支持Windows、macOS和Linux等操作系统，并具有灵活的界面设计和良好的性能。 这些选项都是经过广泛使用和测试的，适用于制作高性能图形化界面应用程序。您可以根据自己的需求和偏好选择合适的工具。"},{"title":"【大模型问答】流行音视频编码对比？-GPT3.5","date":"2023-04-02T07:31:36.000Z","url":"/subweb/blog/2023/04/02/0009.%E6%B5%81%E8%A1%8C%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%AF%B9%E6%AF%94/","tags":[["GPT","/subweb/blog/tags/GPT/"],["视频编码","/subweb/blog/tags/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/"],["音频编码","/subweb/blog/tags/%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81/"],["多媒体","/subweb/blog/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"音频编码下面是一个简单的音频编码对比表格，其中包含常见的音频编码格式和它们的主要参数： 音频编码格式 比特率（kbps） 压缩算法 声音质量 文件大小 ACC 96 - 320 功率谱重建 + 抖动探测 + 简化编码 高 中等 MP3 32 - 320 DCT变换 + 量化 + 离散余弦变换 中等 较小 OGG Vorbis 16 - 500 MDCT变换 + 感知模型 + 渐进编码 高 较小 AAC+ 24 - 64 SBR技术 + 过滤器 + 变换编码 中等 很小 WMA 48 - 192 频域推断 + 码率控制 + 增强编码 中等 中等 FLAC 800 - 1200 无损压缩编码 非常高 大 请注意，这只是一个基本的对比表格，实际的参数可能因所用的软件和具体的设置而有所不同。各种音频编码格式在不同方面都有优势和劣势，具体选择应根据需求和实际情况进行。 视频编码以下是常见的几种视频编码的比较表格： 编码器 压缩率 处理复杂度 适用场景 H.264&#x2F;AVC 高 中等 用于移动设备、流媒体、在线视频和广播电视等视频应用，特别是在有限带宽条件下 H.265&#x2F;HEVC 非常高 非常高 用于4K和8K视频、虚拟现实和网络视频等高分辨率和高质量的视频应用 VP9 中等 中等 主要在YouTube和WebM视频格式中使用，可以提供高画质的视频，同时也支持HDR和4K AV1 非常高 非常高 一个免费开源视频编解码器，可用于多种视频应用，包括流媒体、虚拟现实和在线游戏。具有与HEVC相当的图像质量，但压缩效率更高 MPEG-2 低 低 主要在数字电视广播、DVD和蓝光光盘等传统视频应用中使用 MPEG-4 Part 2 中等 中等 用于互联网视频流媒体和在线视频等应用 AVS 高 中等 中国国家标准的视频编码格式，主要在中国的广播电视和网络视频行业中使用 AVS2 非常高 非常高 AVS的升级版，可用于4K和8K视频等高分辨率应用 注意，上述表格仅供参考，实际情况可能会因为不同的厂商、软件版本和配置而有所不同"},{"title":"【大模型问答】USD开发工程师-GPT3.5","date":"2023-04-01T07:31:36.000Z","url":"/subweb/blog/2023/04/01/0008.USD%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/","tags":[["GPT","/subweb/blog/tags/GPT/"],["USD","/subweb/blog/tags/USD/"],["游戏开发","/subweb/blog/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"],["工作介绍","/subweb/blog/tags/%E5%B7%A5%E4%BD%9C%E4%BB%8B%E7%BB%8D/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"介绍USD开发工程师USD（Universal Scene Description）开发工程师是一种专注于使用USD框架进行场景描述和渲染的软件开发工程师。以下是一个关于USD开发工程师工作内容的简要介绍： 1. USD框架理解和应用： USD是一种用于描述和渲染3D场景的开放标准，开发工程师需要深入了解USD框架的基本原理、架构和功能，并能够将其应用于实际项目中。 2. 开发和维护USD工具和库： USD开发工程师负责开发和维护与USD相关的工具和库，例如USD编辑器、USD插件、Python脚本等。他们需要使用C++或Python等编程语言，根据需求编写高效、稳定的代码。 3. 场景数据管理和优化： USD开发工程师需要处理大规模的场景数据，包括模型、纹理、材质、动画等。他们需要设计和实现数据结构和算法，以优化数据的加载、存储和渲染性能。 4. 渲染管线集成： USD开发工程师与渲染团队合作，将USD与各种渲染引擎（如Arnold、Renderman等）进行集成，确保场景在不同渲染平台上的正确显示和渲染效果。 5. 故障排除和测试： 在开发过程中，USD工程师需要进行故障排除、代码调试和性能优化。他们必须具备良好的问题解决能力，并能够使用调试工具和技术来解决各种技术挑战。 6. 跨团队合作： USD开发工程师通常需要与其他团队成员（如艺术家、动画师、渲染师等）密切合作，了解和满足他们的需求，并提供技术支持和培训。 7. 持续学习和跟进技术发展： 作为一个不断进化的领域，3D场景描述和渲染技术在不断发展。USD开发工程师需要保持对行业新技术的关注，并持续学习和掌握最新的技术和工具。 总的来说，USD开发工程师的工作是将USD框架应用于实际项目中，开发和维护相关工具和库，管理和优化场景数据，并与其他团队成员紧密合作，以实现高效、稳定和优质的3D场景描述和渲染。 USD开发应该学什么，学习路线是什么学习USD开发需要一定的计算机科学和图形学基础知识。以下是一个学习USD开发的典型路线： 1. 编程语言： 学习C++和Python编程语言。C++是USD的主要开发语言，而Python常用于编写USD的脚本和工具。 2. 计算机图形学基础： 理解计算机图形学的基本概念，包括3D几何、渲染管线、着色器等。熟悉OpenGL或其他图形学库也会有帮助。 3. USD框架学习： 深入学习和理解USD框架的核心概念、数据结构和工作原理。掌握Layer、Stage、Prim、Variant、Edit等概念，并了解它们之间的关系与交互。 4. USD工具使用： 学习使用USD相关的工具，如usdcat、usdedit、usdview等，以及其他辅助工具，如USD Python API和USD命令行工具。 5. USD编程接口： 熟悉USD提供的编程接口，包括C++和Python API。了解如何创建、编辑和查询场景描述信息，并对场景进行读取和写入操作。 6. USD扩展功能： 了解如何扩展USD框架，开发自定义的合成器、翻译器、代理和插件。这将使你能够根据特定需求构建自己的USD工具和流程。 7. USD渲染集成： 学习如何将USD与渲染引擎（如Arnold、Renderman等）进行集成，以实现高质量的场景渲染。 8. 实践项目： 参与实际项目，应用所学的USD开发技能解决问题和挑战。通过实践，加深对USD框架的理解和运用能力。 9. 持续学习： 对新的USD版本、扩展和最佳实践保持关注。参与社区讨论、阅读相关文档和教程，不断更新自己的知识。 请注意，这只是一个大致的学习路线，具体的学习内容和进度可能因个人需求和背景而有所不同。建议结合官方文档、在线教程、书籍和其他资源，灵活选择适合自己的学习材料，并通过实际动手实践来加深对USD开发的理解和掌握。"},{"title":"【大模型问答】数据加密存储后如何实现模糊查询？-GPT3.5","date":"2023-03-31T07:31:36.000Z","url":"/subweb/blog/2023/03/31/0007.%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E5%90%8E%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/","tags":[["GPT","/subweb/blog/tags/GPT/"],["数据库","/subweb/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"在数据加密存储后实现模糊查询是一个稍微复杂的问题。由于数据已经加密，传统的模糊查询方法可能无法直接适用。然而，可以考虑以下两种方法来解决这个问题： 使用可搜索加密方案：可搜索加密方案允许在加密数据上进行查询操作而不需要解密整个数据集。这些方案通常基于安全哈希函数、陷门函数等技术，并且提供了一定程度的模糊查询功能。这样，你就可以对加密的数据进行模糊查询，而无需解密数据本身。 结合加密和明文索引：在某些情况下，可以将数据分为加密部分和非敏感的明文索引部分。只有敏感数据被加密，而索引仍然以明文形式存储。在进行模糊查询时，首先在明文索引中查找匹配项，然后使用相应的加密数据进行进一步处理。这种方法需要根据具体需求进行设计和实现，确保对加密数据的访问仍然是安全的。 无论哪种方法，都需要综合考虑数据的安全性和查询效率。同时，还要注意加密算法的选择、密钥管理和数据隐私等问题，并遵守相关的隐私和安全标准。对于具体的应用场景，建议咨询安全专家或数据管理专业人士，以确保实现的方案符合相关的安全要求。"},{"title":"【大模型问答】两步验证相关及解决方案？-GPT3.5","date":"2023-03-30T07:31:36.000Z","url":"/subweb/blog/2023/03/30/0006.%E4%B8%A4%E6%AD%A5%E9%AA%8C%E8%AF%81%E7%9B%B8%E5%85%B3/","tags":[["GPT","/subweb/blog/tags/GPT/"],["安全","/subweb/blog/tags/%E5%AE%89%E5%85%A8/"],["编程","/subweb/blog/tags/%E7%BC%96%E7%A8%8B/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"如何在软件中加入optauth两部验证要在软件中添加两步验证（Two-Factor Authentication，2FA），你可以考虑以下步骤： 选择合适的2FA方法：2FA有多种实现方式，包括短信验证码、时间同步令牌（如Google Authenticator）、硬件安全密钥等。根据你的需求和目标用户，选择适合的2FA方法。 集成2FA库或服务：为了简化开发流程，你可以使用已有的2FA库或第三方2FA服务。这些库和服务通常提供了API和工具来支持2FA功能。一些常用的库和服务包括Google Authenticator、Authy和Duo Security等。 用户注册和绑定：在用户注册过程中，添加一个步骤来启用2FA并绑定用户的设备或账户。这可能涉及生成和显示二维码供用户扫描、发送短信验证码等步骤，以确保用户的身份验证设备与其账户关联。 身份验证过程：在用户登录时，要求用户输入除了用户名和密码之外的额外因素，如2FA生成的验证码。验证输入的验证码是否与预期的一致，并允许用户进入系统。 安全性和管理：确保对于2FA相关信息的存储和传输采取适当的安全措施。管理用户的2FA设置，包括启用、禁用和重置等操作。应考虑备份和恢复用户2FA配置的方法，以防止用户丢失设备或无法访问验证信息。 用户界面和体验：在软件中提供良好的用户界面和用户体验对于2FA至关重要。引导用户设置和管理2FA设置，提供清晰的错误消息和指导，确保用户可以顺利使用2FA功能。 请注意，在实施2FA时，安全性是关键。确保采取合适的安全措施，如加密敏感信息、防范钓鱼攻击等。最好参考相关的安全标准和最佳实践来实现2FA功能，并对其进行充分测试和审查。 Google Authenticator库如何使用要使用Google Authenticator库，你可以按照以下步骤进行： 安装所需的库：首先，确保你的开发环境中已经安装了相应的Google Authenticator库。在大多数编程语言中，你可以使用包管理工具来安装这些库。例如，在Python中，你可以使用pip命令运行pip install pyotp来安装pyotp库。 导入库：在你的代码中导入Google Authenticator库的模块或类。具体导入方法可能因编程语言而异。例如，在Python中，你可以使用import pyotp导入pyotp库。 生成密钥：使用Google Authenticator库生成一个密钥。这个密钥将与用户的账户关联，并用于生成和验证验证码。通常，你可以使用库提供的函数或方法来生成随机的密钥。例如，在pyotp库中，你可以使用pyotp.random_base32()生成一个随机的Base32编码的密钥。 配置验证器：创建Google Authenticator验证器的实例，并将生成的密钥配置到验证器中。这样，验证器就能够根据密钥生成对应的验证码。具体的设置方法取决于所使用的库。在pyotp库中，你可以使用pyotp.TOTP类并传递密钥作为参数来创建TOTP（Time-based One-Time Password）验证器的实例。 生成验证码：使用Google Authenticator验证器生成验证码。根据库的不同，你可能需要提供当前的时间戳或其他必要的参数。在pyotp库中，你可以使用验证器实例 C++请用代码实现Google Authenticator库调用，要求传入对应参数，输出密码在C++中使用Google Authenticator库，你可以使用liboath库来实现。以下是一个简单的示例代码： 这个示例演示了如何使用liboath库生成密码。你需要提供密钥（secret）和当前时间戳（timestamp），然后使用oath_hotp_generate函数生成6位长度的密码。 请注意，此示例仅展示了基本的密码生成过程，实际应用中可能需要更多的输入和验证步骤，以及对错误处理和异常情况的处理。 在使用此示例之前，请确保已经正确安装liboath库，并在编译时链接到该库。具体的编译和链接方法可能因操作系统和开发环境而异。 请用python代码实现Google Authenticator库调用，要求传入对应参数，输出密码在Python中，你可以使用pyotp库来实现Google Authenticator的调用。以下是一个简单的示例代码： 这个示例演示了如何使用pyotp库生成密码。你可以将密钥（secret）传递给TOTP类的构造函数创建TOTP验证器实例。然后，使用now()方法生成当前时间的验证码。 请确保已经安装了pyotp库。你可以使用pip命令运行pip install pyotp进行安装。 这只是一个基本的示例，实际应用可能需要更多的输入和验证步骤，以及对错误处理和异常情况的处理。此外，还可以根据需要使用其他功能来自定义验证器的设置，例如更改密码长度、使用不同的哈希算法等。 希望这可以帮助你开始使用Google Authenticator库进行密码生成。 ptyhon 将指定字符串放到剪贴板要在Python中将指定字符串放入剪贴板，可以使用第三方库pyperclip。请确保你已经安装了该库（使用pip install pyperclip进行安装），然后按照以下示例代码执行： 这段代码中，我们首先导入了pyperclip库。然后，将要复制到剪贴板的字符串保存在变量text中。通过调用pyperclip.copy(text)，将字符串复制到剪贴板中。 最后，我们使用pyperclip.paste()将剪贴板上的内容粘贴到变量paste_text中，并打印出来。 运行这段代码后，你应该能够看到剪贴板被成功复制的文本内容。 请注意，pyperclip库的功能依赖于操作系统的剪贴板支持。在某些情况下，可能需要额外的设置或权限才能正常工作。 请用python代码实现Google Authenticator库调用，传入一个带issuer的secret，输出密码在Python中，你可以使用pyotp库来实现Google Authenticator的调用，包括带有发行者（issuer）的密钥。以下是一个示例代码： 在这个示例中，我们创建了一个TOTP验证器实例，并通过传递secret和issuer参数来设置密钥和发行者。发行者名称会在生成的密码中显示，以提供更好的可读性。 请确保已经安装了pyotp库。你可以使用pip install pyotp命令进行安装。 此代码示例展示了如何使用pyotp库生成密码，并在输出中打印生成的密码。 希望这能帮助你成功地使用带有发行者的密钥调用Google Authenticator库并生成密码。 totp验证器的issuer的作用TOTP（时间同步一次性密码）验证器的发行者（issuer）是可选的信息，用于提供更好的用户识别和区分不同应用程序或服务的标识。它通常在生成的验证码中以文本形式显示。 发行者名称可以帮助用户在Google Authenticator等身份验证应用程序中更轻松地识别和管理各种账户。当用户同时使用多个TOTP验证器时，发行者名称可以使他们更容易辨认每个账户所属的应用或服务。 例如，假设你有一个名为”MyApp”的应用程序，并为其生成了一个TOTP密钥。如果你没有指定发行者名称，那么在Google Authenticator应用程序中，你将只看到一个由6位数字组成的验证码。但是，如果你在创建TOTP验证器时指定了发行者为”MyApp”，则在Google Authenticator中，该账户将以”MyApp”开头，例如”MyApp: 123456”，这样你就能更容易地识别该密码与哪个应用相关联。 发行者名称在密码生成过程中并不影响安全性。它仅作为标识符的一部分，以增加用户识别和管理的便利性。如果你不需要发行者名称，可以省略它，而只使用密钥生成密码。 总而言之，发行者名称是可选的元数据，用于在生成的TOTP密码中提供更好的标识和用户体验，以便用户能够更轻松地区分不同应用程序或服务的身份验证账户。"},{"title":"【大模型问答】C++实现网络数据包的抓取？-GPT3.5","date":"2023-03-28T07:31:36.000Z","url":"/subweb/blog/2023/03/28/0005.C++%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E6%8A%93%E5%8F%96/","tags":[["GPT","/subweb/blog/tags/GPT/"],["网络","/subweb/blog/tags/%E7%BD%91%E7%BB%9C/"],["C++","/subweb/blog/tags/C/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"以下是一个使用C++编写的简单程序，用于抓取网络数据包： 这个程序使用了 pcap 库来进行网络数据包的抓取。首先，它打开了一个网络设备，然后可以设置过滤器来选择特定类型或端口的数据包进行捕获。在 packetHandler 函数中，可以处理抓到的每个数据包。这里只是简单地输出一条消息，你可以根据自己的需求对数据包进行相应的处理。 请注意，由于需要访问网络设备，因此执行此程序可能需要管理员权限。还要确保已安装 libpcap 库和相应的开发包。具体的编译和运行方式可能会有所不同，具体取决于你所使用的操作系统和编译环境。"},{"title":"【大模型问答】为什么CISC指令集在多方面不如RISC，却仍被广泛使用？-GPT3.5","date":"2023-03-27T07:31:36.000Z","url":"/subweb/blog/2023/03/27/0004.%E4%B8%BA%E4%BB%80%E4%B9%88CISC%E6%8C%87%E4%BB%A4%E9%9B%86%E5%9C%A8%E5%A4%9A%E6%96%B9%E9%9D%A2%E4%B8%8D%E5%A6%82RISC%EF%BC%8C%E5%8D%B4%E4%BB%8D%E8%A2%AB%E5%B9%BF%E6%B3%9B%E4%BD%BF%E7%94%A8/","tags":[["GPT","/subweb/blog/tags/GPT/"],["指令集","/subweb/blog/tags/%E6%8C%87%E4%BB%A4%E9%9B%86/"],["处理器架构","/subweb/blog/tags/%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"CISC（复杂指令集计算机）和RISC（精简指令集计算机）是两种不同的指令集架构。尽管CISC在多方面不如RISC，但它仍然被广泛使用有以下几个原因： 兼容性：CISC架构的普及源于早期计算机系统的设计，许多旧的软件和系统仍然依赖于CISC架构。为了兼容这些传统系统和软件，现代计算机仍然支持CISC指令集。 多功能性：CISC指令集具有丰富的操作码，可以执行一条指令完成复杂的操作。这使得编程人员可以用更少的指令来实现复杂的任务，从而提高编程的效率。 芯片空间利用率：由于CISC指令可以完成更多的操作，相对于RISC，执行同样的任务所需的指令数量较少。这意味着CISC处理器可以用较少的芯片空间来存储指令集，并且可以在单个指令周期内执行更多的操作。 硬件优化：CISC指令集中的某些指令可以直接在硬件级别上执行，从而减少了对软件的依赖，提高了执行效率。这种硬件优化对一些特定的应用场景非常有利。 尽管RISC架构在某些方面有优势，如更简化的指令集、更高的执行效率和更易于设计的处理器等，但CISC仍然被广泛使用是由于上述原因。实际上，许多现代处理器采用了混合的CISC和RISC特性，以兼顾各种需求。"},{"title":"【大模型问答】IPV4早就用完了，为什么我们现在上网还能分到公网可访问的公网IP？-GPT3.5","date":"2023-03-26T07:31:36.000Z","url":"/subweb/blog/2023/03/26/0003.IPV4%E6%97%A9%E5%B0%B1%E7%94%A8%E5%AE%8C%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E4%B8%8A%E7%BD%91%E8%BF%98%E8%83%BD%E5%88%86%E5%88%B0%E5%85%AC%E7%BD%91%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E5%85%AC%E7%BD%91IP/","tags":[["GPT","/subweb/blog/tags/GPT/"],["网络","/subweb/blog/tags/%E7%BD%91%E7%BB%9C/"],["IP","/subweb/blog/tags/IP/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"实际上，IPv4地址空间是有限的，且已经基本用完。然而，我们仍然能够访问公网可访问的公网IP地址的原因如下： 地址分配策略：IPv4地址池按照国家和地区进行分配，由互联网注册机构（RIRs）负责进行地址分配。这些机构根据实际需求和规则分配地址，确保更加有效地利用有限的地址资源。 网络地址转换（NAT）：NAT是一种技术，将私有IP地址转换为公共IP地址或者多个私有地址映射到一个公共地址。这样做可以通过在网络边界上的路由器或防火墙上执行地址转换，使得多个设备共享一个公网IP地址，从而缓解了IPv4地址紧缺的问题。 IPv6的部署：由于IPv4地址紧缺的问题，IPv6被开发出来以解决此问题。IPv6使用128位地址空间，提供了大量的IP地址，足够满足未来的需求。逐渐地，互联网服务供应商（ISPs）和网络运营商开始支持IPv6，并向用户提供IPv6地址，以扩展互联网的寻址能力。 尽管目前我们还在使用IPv4，但采取上述措施，我们仍然能够获得公网可访问的公网IP地址。不过，随着IPv6的普及和逐渐取代IPv4的过程，我们将能够更好地解决地址资源短缺的问题。"},{"title":"【大模型问答】世界上第一个操作系统使用机器语言写的么？-GPT3.5","date":"2023-03-25T07:31:36.000Z","url":"/subweb/blog/2023/03/25/0002.%E4%B8%96%E7%95%8C%E4%B8%8A%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E5%86%99%E7%9A%84%E4%B9%88%EF%BC%9F/","tags":[["GPT","/subweb/blog/tags/GPT/"],["机器语言","/subweb/blog/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/"],["计算机历史","/subweb/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%86%E5%8F%B2/"],["操作系统","/subweb/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"不，世界上第一个操作系统并不是使用机器语言编写的。在早期计算机发展的阶段，用于控制计算机硬件和管理资源的软件是以机器语言的形式编写的，这种语言直接与计算机的底层硬件进行交互。然而，第一个被广泛认可的操作系统——UNIVAC I操作系统（也称为最早的商业操作系统）并不是使用机器语言编写的。 UNIVAC I操作系统于1951年发布，它是在汇编语言中编写的。尽管汇编语言比机器语言更高级，但仍需要直接操作硬件指令。后来，随着技术的进步，出现了更高级的编程语言，如FORTRAN和COBOL，这些语言使得操作系统的开发变得更加高效和易于理解。因此，尽管最早的操作系统使用较低级别的语言编写，但它们并非纯粹的机器语言。"},{"title":"【大模型问答】如何使用openMVG的函数式接口生成点云？-GPT3.5","date":"2023-03-24T07:31:36.000Z","url":"/subweb/blog/2023/03/24/0001.%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8openMVG%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%94%9F%E6%88%90%E7%82%B9%E4%BA%91/","tags":[["GPT","/subweb/blog/tags/GPT/"],["三维重建","/subweb/blog/tags/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"],["openMVG","/subweb/blog/tags/openMVG/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"要使用OpenMVG的函数式接口生成点云，需要按照以下步骤操作： 导入OpenMVG库并包含头文件： 加载图像和特征： 使用函数式接口生成点云： 这样就可以使用OpenMVG的函数式接口生成点云了。需要注意的是，这只是一个简单的示例代码，实际应用中需要根据具体情况进行调整和优化。"}]