[{"title":"【动漫】动漫列表-长期更新","date":"2024-04-02T09:47:25.000Z","url":"/subweb/blog/2024/04/02/0012.%E5%8A%A8%E6%BC%AB%E5%88%97%E8%A1%A8-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/","tags":[["动漫","/subweb/blog/tags/%E5%8A%A8%E6%BC%AB/"],["日漫","/subweb/blog/tags/%E6%97%A5%E6%BC%AB/"],["原盘","/subweb/blog/tags/%E5%8E%9F%E7%9B%98/"]],"categories":[["动漫","/subweb/blog/categories/%E5%8A%A8%E6%BC%AB/"]],"content":"说明列表内容均参考自泛式的新番导视视频。 各种前置标记为优先级，从高到低分别为 @、 # 、$、 % 加粗字体表示正在下载 删除线字体表示已经下载完毕 更新时间：2024-4-2 17:47:25 列表2023-72023-10续作组0:15-《进击的巨人 完结篇 后篇》0:26-《间谍过家家2》#0:37-《偶像大师 百万现场》文艺复兴重置版0:48-《恶魔君》 《仙魔大战》0:52-《想要成为影之实力者2》0:54-《哥布林杀手2》0:56-《世界尽头的圣骑士2》0:58-《圣女魔力无所不能2》1:00-《女友成堆2》1:02-《铁路浪漫谭2》1:04-《拳愿阿修罗2》1:06-《催眠麦克风2》1:07-《绊之Allele2》#1:09-《盾之勇者成名录3》1:11-《亡骸游戏2》1:12-《石纪元 新世界part2》1:14-《魔法使新娘2part2》1:16-《东京复仇者 天竺篇》1:18-《足球小将 世少篇》1:20-《七大罪:默示录的四骑士》1:23-《B-PRIJECT～热烈字符号*Love Call ～》1:24-《赛马娘3》新作组#1:49-《葬送的芙莉莲》由MAD HOUSE担当制作导演:斋藤圭一 其他作品:《孤独摇滚》#3:03-《不死不幸》由大卫社担当制作《炎炎消防队》3:29-《药屋少女的呢喃》导演:長沼範裕 其他作品:《魔法新娘使》3:59-《超超超超喜欢你的100个女朋友》4:32-《位于恋爱光谱极端的我们》别名:《经验丰富的你与经验为零的我交往的故事》4:57-《腼腆英雄》5:28-《星灵感应》5:54-《狩龙人拉格纳》由Silver Link制作6:30-《破灭之国》6:54-《鸭乃桥论的禁忌推理》漫画作者:天野明 其他作品:《家庭教师》7:16-《米奇与达利》作者:佐野菜见老师（R.I.P） 其他作品:《在下坂本》8:02-《地下忍者》由手冢P制作8:32-《特搜组大吾 救国的橘色部队》8:59-《16bit的感动》9:37-《凹凸魔女的亲子日常》9:44-《柚木家的四兄弟》9:53-《晚安世界》10:06《大小姐与看门犬》10:20-《极速车魂》10:29-《圣剑学院的魔剑使》原作:志瑞祐 其他作品；《精灵使的剑舞》10:52-《家里蹲吸血姬的苦闷》由P9担当制作 #11:19-《靠着魔法药水在异世界活下去》作者:FUNA 其他作品:《能力平均值》《养老八万金》#11:34-《提亚穆帝国物语～从断头台开始，公主重生的逆转人生》#11:48-《我推是反派大小姐》#12:04-《捡走被人悔婚的千金，教会她坏坏的幸福生活》12:18-《想当冒险者前往大都市的儿女已经升到了5级》12:32-《猪肝记得煮熟再吃》12:53-《暴食狂战士～只有我突破了等级概念～》13:12-《归还者的魔法要特别》13:28-《莫大叔的VRMMO活动记》#13:52-《香格里拉边境～粪作猎人向神作游戏发起挑战～》14:15-《KamiErabi》原创企划:JIN14:23-《Overtake》执导:青木英 同时是《fate&#x2F;zero》《异度入侵》的导演14:28-《Paradox Live THE ANIMATION》14:31-《川越男子合唱团》#14:37-《我们的雨色协议》14:59-《PLUTO～冥王》原作:浦泽直树 由网飞出品 2024-1续作 我心里危险的东西2 龙与魔女 #0.8 奇异贤伴 黑色天使 part2 青之驱魔师 岛根启明结社篇 通灵王 FLOWERS 福星小子 重制版 2 #物理魔法使马修 2 狩火之王 2 至高之牌 2 月光下的异世界之旅 2 因为不是真正的伙伴被赶出勇者队伍 2 弱角友崎同学 2 欢迎来到实力至上主义教师 3 王者天下 5 《王者天下 5》 《暗芝居 12》 《卡片战斗先导者 ？？？》 新作 #《迷宫饭》 《我独自升级》 《魔女与野兽》 #《魔都精灵的奴隶》 #《憧憬成为魔法少女》 《休假日的坏人先生》 #《愚蠢天使与恶魔共舞》 #《公主大人“拷问时间到”》 《佐佐木与文鸟小哔》 #《为了在异世界抚摸毛茸茸而努力》 #《最弱驯兽师开启捡垃圾旅途》 《事与愿违的不死冒险者》 《治愈魔法的错误使用方法奔赴战场的回复要员》 《秒杀外挂太强了，异世界的家伙根本不是对手》 《最强肉盾的迷宫攻略~拥有稀有技能血量9999的肉盾被勇者队伍辞退》 #《恶役千金lv99我是隐藏boss但不是魔王》 #《外科医生爱丽丝》 #《轮回七次的恶役千金，在前敌国享受随心所欲的新婚生活》 《异修罗》 #《指尖相触，恋恋不舍》 《战国妖狐》 《北海道辣妹贼拉可爱》 《百千家的妖怪王子》 《到了30岁还是童真似乎会变成魔法师》 《婚戒物语》 原创 《勇气爆发Bang Bravern》 #《碰之道》 《月刊妄想科学》 《Bucchigiri》 #《Metallic Rouge》 金属口红 2024-4续作组： 《京吹 3》 《为美好的世界献上祝福 3》 《摇曳露营 3》 三部老番重制版 《调酒师 神之杯》 《狼与香辛料 行商邂逅贤狼》 《新·亚拉那一卡》 《无知转生 2 part2》 《转生史莱姆 3》 《死神少爷与黑女仆 3》 《魔法科高校劣等生 3》 《约会大作战 5》 《虹四格动画 2》 《影之诗F ArkRuler篇》 《秘密偶像公主》（美妙系列新作） 《新干线变形机器人 改变世界》 《黑执事 -寄宿学校篇-》 《鬼灭之人 柱训练篇》 新作： 《怪兽8号》 《恋语轻唱》 《战队大失格》 《爷爷奶奶返老还童》 《格斗实况》 《杀手寓言》 《防风少年》 《夜樱家大作战》 《渴求游戏之神》 《怪人的沙拉碗》 《声优广播的幕前幕后》 《无名记忆》 《良禽不择木》 《单间、光照尚好、附带天使》 《吸血鬼男子宿舍》 《我回来了，欢迎回来》 《与妖为邻》 《喂！蜻蜓》 《失忆投捕》 《怪异与少女与神隐》 《被称为废物的原英雄，被家里流放随心所欲活下去》 《身为魔王的我娶了奴隶精灵为妻，该如何表白我的爱？》 《转生为第七王子，随心所欲的魔法学习之路》 《从Lv2开始开挂的原勇者候补悠闲的异世界生活》 《转生贵族靠着鉴定技能一飞冲天》 《Re:Monster》 游戏改编动画： 《刀剑乱舞 廻 -虚传 燃烧的本能寺-》 《偶像大师 闪耀色彩》 《雀魂 杠！！》 《碧蓝档案 动画版》 原创： 《アスト曰&#x2F;オト》《Astro Note》（暂译：外星笔记） 《未班列车去哪里？》 《竞轮少女》 《HIGHSPEED Etoile》(暂译:高速星辰) 《GIRLS BAND CRY》（哭泣少女乐队） 《夜晚的水母不游泳》"},{"title":"【大模型问答】蓝光光盘中的PV,Teaser,Menu,IV,CM,Character PV分别指什么？-GPT3.5","date":"2023-04-04T07:31:36.000Z","url":"/subweb/blog/2023/04/04/0011.%E8%93%9D%E5%85%89%E5%85%89%E7%9B%98%E4%B8%AD%E7%9A%84PV,Teaser,Menu,IV,CM,Character%20PV%E5%88%86%E5%88%AB%E6%8C%87%E4%BB%80%E4%B9%88/","tags":[["GPT","/subweb/blog/tags/GPT/"],["影视","/subweb/blog/tags/%E5%BD%B1%E8%A7%86/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"蓝光光盘中的PV, Teaser, Menu, IV, CM, Character PV分别指以下内容： PV（Promotional Video）：这是一种用于宣传目的的视频，通常用于预告电影、动画、游戏等媒体作品。在蓝光光盘中，PV通常是该作品的预告片或广告片。 Teaser（预告片）：这是一种短暂而引人注目的视频片段，用于提前宣传即将发行的电影、剧集或游戏等作品。Teaser通常为全新作品的首个预告片，以引起观众的兴趣和好奇心。 Menu（菜单）：这是蓝光光盘中的交互式界面，类似于DVD上的菜单。菜单可以包括选项如“开始播放”、“选择章节”、“设置”等，并提供用户导航和控制光盘内容的功能。 IV（Image Video）：这是一种图像视频，在蓝光光盘中通常用于展示与作品相关的插图、画廊、幕后花絮、特写镜头等额外内容。IV提供了更多的视觉展示，增强了用户对作品的理解和欣赏。 CM（Commercial Message）：这指的是商业广告片，在蓝光光盘中通常包括与作品相关的广告。这些广告可能是为了其他相关产品、服务或合作伙伴而制作，以在光盘播放期间向观众展示。 Character PV（角色PV）：这是一种特殊类型的PV，用于突出作品中的角色。Character PV通常以某个主要角色为重点，通过短片或特别预告片来展示该角色的特点、背景故事或魅力，以吸引观众对角色的关注。 "},{"title":"【大模型问答】vulkan，openGL，DX等图形接口-GPT3.5","date":"2023-04-03T07:31:36.000Z","url":"/subweb/blog/2023/04/03/0010.vulkan%EF%BC%8CopenGL%EF%BC%8CDX%E7%AD%89%E5%9B%BE%E5%BD%A2%E6%8E%A5%E5%8F%A3/","tags":[["GPT","/subweb/blog/tags/GPT/"],["编程","/subweb/blog/tags/%E7%BC%96%E7%A8%8B/"],["图形接口","/subweb/blog/tags/%E5%9B%BE%E5%BD%A2%E6%8E%A5%E5%8F%A3/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"Vulkan,OpenGL,DirectX对比Vulkan，OpenGL和DirectX（DX）是常用的图形接口，被广泛用于游戏和图形应用开发。它们都有各自的特点和优势，因此很难一概而论哪个接口性能更强。 下面是对每个接口的简要介绍： Vulkan：Vulkan是一个跨平台的低级别图形和计算API。它提供了更直接的硬件访问和更多的控制权，允许开发人员更好地利用GPU的性能。Vulkan使用异步、并行的方式工作，并且对多线程处理有很好的支持。由于其底层性质，Vulkan通常在需要高度优化和对设备资源需求较大的场景下表现出色，例如使用大规模渲染技术或进行复杂的计算。 OpenGL：OpenGL是一个跨平台的图形API，广泛用于实时渲染和图形应用程序开发。它具有较高的稳定性和兼容性，并且易于学习和使用。然而，由于OpenGL的设计较早，它在性能方面可能不如Vulkan或DirectX。尽管如此，许多游戏和应用程序仍然使用OpenGL，并且在某些情况下，它可以提供足够的性能来满足需求。 DirectX（包括DirectX 11和DirectX 12）：DirectX是由Microsoft开发的一组技术，用于Windows平台上的多媒体和游戏开发。DirectX在Windows系统上提供了广泛的功能和工具，可以方便地进行图形和多媒体编程。DirectX 12是最新版本，引入了更低级别的API设计，类似于Vulkan，并且对多线程和并行处理有更好的支持。DirectX通常在Windows平台上具有较好的性能，尤其是在与硬件紧密合作并使用专门优化的驱动程序时。 要确定哪个接口具有更强大的性能，需要考虑许多因素，如应用程序的性质、目标平台、硬件配置以及开发人员的熟练程度。在实际应用中，根据具体需求选择适合的接口和技术是很重要的。 除了vulkan，openGL，DX以外，还有哪些高性能的图形接口除了Vulkan、OpenGL和DirectX，还有一些其他高性能的图形接口可供选择。以下是其中几个常用的选项： Metal：由苹果公司开发的图形接口，专为iOS和macOS系统设计，具有低延迟和高效能的特点。 WebGPU：Web浏览器中的图形编程接口，旨在提供与现代图形硬件更直接的交互，实现高性能的Web图形渲染。 DirectX 12 Ultimate：微软最新版本的图形API，提供对Windows平台上最新的图形硬件特性的支持，具有高度优化的性能和功能。 CUDA：由NVIDIA开发的并行计算平台和编程模型，主要用于利用NVIDIA GPU进行高性能计算和图形处理。 OpenCL：跨平台的并行计算框架，支持多种处理器架构，包括CPU、GPU和FPGA等，用于实现高性能通用计算任务。 WebGL：基于Web标准的图形接口，允许在Web浏览器中使用JavaScript进行硬件加速的3D图形渲染。 这些接口都具有不同的特点和适用范围，开发者可以根据具体需求选择最适合自己项目的图形接口。 QT是否属于图形接口是的，QT（跨平台应用程序和用户界面开发框架）是一种图形接口。它提供了一套功能强大的工具和库，用于创建各种类型的图形用户界面（GUI）应用程序。QT具有丰富的图形控件、布局管理器、绘图功能以及事件处理等特性，使开发人员能够轻松构建现代化、可交互的应用程序界面。同时，QT也提供了对不同操作系统的支持，包括Windows、macOS、Linux等，使开发者能够编写一次代码，然后在多个平台上运行其应用程序。 除了QT外，还有哪些高性能图形接口适合制作图形化界面除了QT外，还有一些其他高性能图形接口适合制作图形化界面的选择。以下是几个常用的选项： WxWidgets：WxWidgets 是一个跨平台的 C++ 图形用户界面库，它提供了类似于QT的开发体验。它支持多种操作系统，包括Windows、macOS和Linux等。WxWidgets具有良好的性能和丰富的控件库，可以用于开发图形化界面应用程序。 **GTK+**：GTK+ 是一个跨平台的图形用户界面工具包，使用C语言编写，但也支持其他编程语言如C++、Python等。它是GNOME桌面环境的标准工具包，支持多种操作系统。GTK+有很好的性能和可扩展性，并提供了丰富的控件库和主题支持。 JavaFX：JavaFX 是Java平台上专为创建富客户端应用程序设计的图形库。它提供了丰富的控件库、动画效果和多媒体功能。JavaFX的性能良好，并且与Java紧密集成，适用于开发Java应用程序的图形界面。 Electron：Electron 是一个基于Web技术（HTML、CSS、JavaScript）的桌面应用程序开发框架。使用Electron，您可以使用Web技术开发跨平台的图形界面应用程序。它支持Windows、macOS和Linux等操作系统，并具有灵活的界面设计和良好的性能。 这些选项都是经过广泛使用和测试的，适用于制作高性能图形化界面应用程序。您可以根据自己的需求和偏好选择合适的工具。"},{"title":"【大模型问答】流行音视频编码对比？-GPT3.5","date":"2023-04-02T07:31:36.000Z","url":"/subweb/blog/2023/04/02/0009.%E6%B5%81%E8%A1%8C%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%AF%B9%E6%AF%94/","tags":[["GPT","/subweb/blog/tags/GPT/"],["视频编码","/subweb/blog/tags/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/"],["音频编码","/subweb/blog/tags/%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81/"],["多媒体","/subweb/blog/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"音频编码下面是一个简单的音频编码对比表格，其中包含常见的音频编码格式和它们的主要参数： 音频编码格式 比特率（kbps） 压缩算法 声音质量 文件大小 ACC 96 - 320 功率谱重建 + 抖动探测 + 简化编码 高 中等 MP3 32 - 320 DCT变换 + 量化 + 离散余弦变换 中等 较小 OGG Vorbis 16 - 500 MDCT变换 + 感知模型 + 渐进编码 高 较小 AAC+ 24 - 64 SBR技术 + 过滤器 + 变换编码 中等 很小 WMA 48 - 192 频域推断 + 码率控制 + 增强编码 中等 中等 FLAC 800 - 1200 无损压缩编码 非常高 大 请注意，这只是一个基本的对比表格，实际的参数可能因所用的软件和具体的设置而有所不同。各种音频编码格式在不同方面都有优势和劣势，具体选择应根据需求和实际情况进行。 视频编码以下是常见的几种视频编码的比较表格： 编码器 压缩率 处理复杂度 适用场景 H.264&#x2F;AVC 高 中等 用于移动设备、流媒体、在线视频和广播电视等视频应用，特别是在有限带宽条件下 H.265&#x2F;HEVC 非常高 非常高 用于4K和8K视频、虚拟现实和网络视频等高分辨率和高质量的视频应用 VP9 中等 中等 主要在YouTube和WebM视频格式中使用，可以提供高画质的视频，同时也支持HDR和4K AV1 非常高 非常高 一个免费开源视频编解码器，可用于多种视频应用，包括流媒体、虚拟现实和在线游戏。具有与HEVC相当的图像质量，但压缩效率更高 MPEG-2 低 低 主要在数字电视广播、DVD和蓝光光盘等传统视频应用中使用 MPEG-4 Part 2 中等 中等 用于互联网视频流媒体和在线视频等应用 AVS 高 中等 中国国家标准的视频编码格式，主要在中国的广播电视和网络视频行业中使用 AVS2 非常高 非常高 AVS的升级版，可用于4K和8K视频等高分辨率应用 注意，上述表格仅供参考，实际情况可能会因为不同的厂商、软件版本和配置而有所不同"},{"title":"【大模型问答】USD开发工程师-GPT3.5","date":"2023-04-01T07:31:36.000Z","url":"/subweb/blog/2023/04/01/0008.USD%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/","tags":[["GPT","/subweb/blog/tags/GPT/"],["USD","/subweb/blog/tags/USD/"],["游戏开发","/subweb/blog/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"],["工作介绍","/subweb/blog/tags/%E5%B7%A5%E4%BD%9C%E4%BB%8B%E7%BB%8D/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"介绍USD开发工程师USD（Universal Scene Description）开发工程师是一种专注于使用USD框架进行场景描述和渲染的软件开发工程师。以下是一个关于USD开发工程师工作内容的简要介绍： 1. USD框架理解和应用： USD是一种用于描述和渲染3D场景的开放标准，开发工程师需要深入了解USD框架的基本原理、架构和功能，并能够将其应用于实际项目中。 2. 开发和维护USD工具和库： USD开发工程师负责开发和维护与USD相关的工具和库，例如USD编辑器、USD插件、Python脚本等。他们需要使用C++或Python等编程语言，根据需求编写高效、稳定的代码。 3. 场景数据管理和优化： USD开发工程师需要处理大规模的场景数据，包括模型、纹理、材质、动画等。他们需要设计和实现数据结构和算法，以优化数据的加载、存储和渲染性能。 4. 渲染管线集成： USD开发工程师与渲染团队合作，将USD与各种渲染引擎（如Arnold、Renderman等）进行集成，确保场景在不同渲染平台上的正确显示和渲染效果。 5. 故障排除和测试： 在开发过程中，USD工程师需要进行故障排除、代码调试和性能优化。他们必须具备良好的问题解决能力，并能够使用调试工具和技术来解决各种技术挑战。 6. 跨团队合作： USD开发工程师通常需要与其他团队成员（如艺术家、动画师、渲染师等）密切合作，了解和满足他们的需求，并提供技术支持和培训。 7. 持续学习和跟进技术发展： 作为一个不断进化的领域，3D场景描述和渲染技术在不断发展。USD开发工程师需要保持对行业新技术的关注，并持续学习和掌握最新的技术和工具。 总的来说，USD开发工程师的工作是将USD框架应用于实际项目中，开发和维护相关工具和库，管理和优化场景数据，并与其他团队成员紧密合作，以实现高效、稳定和优质的3D场景描述和渲染。 USD开发应该学什么，学习路线是什么学习USD开发需要一定的计算机科学和图形学基础知识。以下是一个学习USD开发的典型路线： 1. 编程语言： 学习C++和Python编程语言。C++是USD的主要开发语言，而Python常用于编写USD的脚本和工具。 2. 计算机图形学基础： 理解计算机图形学的基本概念，包括3D几何、渲染管线、着色器等。熟悉OpenGL或其他图形学库也会有帮助。 3. USD框架学习： 深入学习和理解USD框架的核心概念、数据结构和工作原理。掌握Layer、Stage、Prim、Variant、Edit等概念，并了解它们之间的关系与交互。 4. USD工具使用： 学习使用USD相关的工具，如usdcat、usdedit、usdview等，以及其他辅助工具，如USD Python API和USD命令行工具。 5. USD编程接口： 熟悉USD提供的编程接口，包括C++和Python API。了解如何创建、编辑和查询场景描述信息，并对场景进行读取和写入操作。 6. USD扩展功能： 了解如何扩展USD框架，开发自定义的合成器、翻译器、代理和插件。这将使你能够根据特定需求构建自己的USD工具和流程。 7. USD渲染集成： 学习如何将USD与渲染引擎（如Arnold、Renderman等）进行集成，以实现高质量的场景渲染。 8. 实践项目： 参与实际项目，应用所学的USD开发技能解决问题和挑战。通过实践，加深对USD框架的理解和运用能力。 9. 持续学习： 对新的USD版本、扩展和最佳实践保持关注。参与社区讨论、阅读相关文档和教程，不断更新自己的知识。 请注意，这只是一个大致的学习路线，具体的学习内容和进度可能因个人需求和背景而有所不同。建议结合官方文档、在线教程、书籍和其他资源，灵活选择适合自己的学习材料，并通过实际动手实践来加深对USD开发的理解和掌握。"},{"title":"【大模型问答】数据加密存储后如何实现模糊查询？-GPT3.5","date":"2023-03-31T07:31:36.000Z","url":"/subweb/blog/2023/03/31/0007.%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E5%90%8E%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/","tags":[["GPT","/subweb/blog/tags/GPT/"],["数据库","/subweb/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"在数据加密存储后实现模糊查询是一个稍微复杂的问题。由于数据已经加密，传统的模糊查询方法可能无法直接适用。然而，可以考虑以下两种方法来解决这个问题： 使用可搜索加密方案：可搜索加密方案允许在加密数据上进行查询操作而不需要解密整个数据集。这些方案通常基于安全哈希函数、陷门函数等技术，并且提供了一定程度的模糊查询功能。这样，你就可以对加密的数据进行模糊查询，而无需解密数据本身。 结合加密和明文索引：在某些情况下，可以将数据分为加密部分和非敏感的明文索引部分。只有敏感数据被加密，而索引仍然以明文形式存储。在进行模糊查询时，首先在明文索引中查找匹配项，然后使用相应的加密数据进行进一步处理。这种方法需要根据具体需求进行设计和实现，确保对加密数据的访问仍然是安全的。 无论哪种方法，都需要综合考虑数据的安全性和查询效率。同时，还要注意加密算法的选择、密钥管理和数据隐私等问题，并遵守相关的隐私和安全标准。对于具体的应用场景，建议咨询安全专家或数据管理专业人士，以确保实现的方案符合相关的安全要求。"},{"title":"【大模型问答】两步验证相关及解决方案？-GPT3.5","date":"2023-03-30T07:31:36.000Z","url":"/subweb/blog/2023/03/30/0006.%E4%B8%A4%E6%AD%A5%E9%AA%8C%E8%AF%81%E7%9B%B8%E5%85%B3/","tags":[["GPT","/subweb/blog/tags/GPT/"],["安全","/subweb/blog/tags/%E5%AE%89%E5%85%A8/"],["编程","/subweb/blog/tags/%E7%BC%96%E7%A8%8B/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"如何在软件中加入optauth两部验证要在软件中添加两步验证（Two-Factor Authentication，2FA），你可以考虑以下步骤： 选择合适的2FA方法：2FA有多种实现方式，包括短信验证码、时间同步令牌（如Google Authenticator）、硬件安全密钥等。根据你的需求和目标用户，选择适合的2FA方法。 集成2FA库或服务：为了简化开发流程，你可以使用已有的2FA库或第三方2FA服务。这些库和服务通常提供了API和工具来支持2FA功能。一些常用的库和服务包括Google Authenticator、Authy和Duo Security等。 用户注册和绑定：在用户注册过程中，添加一个步骤来启用2FA并绑定用户的设备或账户。这可能涉及生成和显示二维码供用户扫描、发送短信验证码等步骤，以确保用户的身份验证设备与其账户关联。 身份验证过程：在用户登录时，要求用户输入除了用户名和密码之外的额外因素，如2FA生成的验证码。验证输入的验证码是否与预期的一致，并允许用户进入系统。 安全性和管理：确保对于2FA相关信息的存储和传输采取适当的安全措施。管理用户的2FA设置，包括启用、禁用和重置等操作。应考虑备份和恢复用户2FA配置的方法，以防止用户丢失设备或无法访问验证信息。 用户界面和体验：在软件中提供良好的用户界面和用户体验对于2FA至关重要。引导用户设置和管理2FA设置，提供清晰的错误消息和指导，确保用户可以顺利使用2FA功能。 请注意，在实施2FA时，安全性是关键。确保采取合适的安全措施，如加密敏感信息、防范钓鱼攻击等。最好参考相关的安全标准和最佳实践来实现2FA功能，并对其进行充分测试和审查。 Google Authenticator库如何使用要使用Google Authenticator库，你可以按照以下步骤进行： 安装所需的库：首先，确保你的开发环境中已经安装了相应的Google Authenticator库。在大多数编程语言中，你可以使用包管理工具来安装这些库。例如，在Python中，你可以使用pip命令运行pip install pyotp来安装pyotp库。 导入库：在你的代码中导入Google Authenticator库的模块或类。具体导入方法可能因编程语言而异。例如，在Python中，你可以使用import pyotp导入pyotp库。 生成密钥：使用Google Authenticator库生成一个密钥。这个密钥将与用户的账户关联，并用于生成和验证验证码。通常，你可以使用库提供的函数或方法来生成随机的密钥。例如，在pyotp库中，你可以使用pyotp.random_base32()生成一个随机的Base32编码的密钥。 配置验证器：创建Google Authenticator验证器的实例，并将生成的密钥配置到验证器中。这样，验证器就能够根据密钥生成对应的验证码。具体的设置方法取决于所使用的库。在pyotp库中，你可以使用pyotp.TOTP类并传递密钥作为参数来创建TOTP（Time-based One-Time Password）验证器的实例。 生成验证码：使用Google Authenticator验证器生成验证码。根据库的不同，你可能需要提供当前的时间戳或其他必要的参数。在pyotp库中，你可以使用验证器实例 C++请用代码实现Google Authenticator库调用，要求传入对应参数，输出密码在C++中使用Google Authenticator库，你可以使用liboath库来实现。以下是一个简单的示例代码： 这个示例演示了如何使用liboath库生成密码。你需要提供密钥（secret）和当前时间戳（timestamp），然后使用oath_hotp_generate函数生成6位长度的密码。 请注意，此示例仅展示了基本的密码生成过程，实际应用中可能需要更多的输入和验证步骤，以及对错误处理和异常情况的处理。 在使用此示例之前，请确保已经正确安装liboath库，并在编译时链接到该库。具体的编译和链接方法可能因操作系统和开发环境而异。 请用python代码实现Google Authenticator库调用，要求传入对应参数，输出密码在Python中，你可以使用pyotp库来实现Google Authenticator的调用。以下是一个简单的示例代码： 这个示例演示了如何使用pyotp库生成密码。你可以将密钥（secret）传递给TOTP类的构造函数创建TOTP验证器实例。然后，使用now()方法生成当前时间的验证码。 请确保已经安装了pyotp库。你可以使用pip命令运行pip install pyotp进行安装。 这只是一个基本的示例，实际应用可能需要更多的输入和验证步骤，以及对错误处理和异常情况的处理。此外，还可以根据需要使用其他功能来自定义验证器的设置，例如更改密码长度、使用不同的哈希算法等。 希望这可以帮助你开始使用Google Authenticator库进行密码生成。 ptyhon 将指定字符串放到剪贴板要在Python中将指定字符串放入剪贴板，可以使用第三方库pyperclip。请确保你已经安装了该库（使用pip install pyperclip进行安装），然后按照以下示例代码执行： 这段代码中，我们首先导入了pyperclip库。然后，将要复制到剪贴板的字符串保存在变量text中。通过调用pyperclip.copy(text)，将字符串复制到剪贴板中。 最后，我们使用pyperclip.paste()将剪贴板上的内容粘贴到变量paste_text中，并打印出来。 运行这段代码后，你应该能够看到剪贴板被成功复制的文本内容。 请注意，pyperclip库的功能依赖于操作系统的剪贴板支持。在某些情况下，可能需要额外的设置或权限才能正常工作。 请用python代码实现Google Authenticator库调用，传入一个带issuer的secret，输出密码在Python中，你可以使用pyotp库来实现Google Authenticator的调用，包括带有发行者（issuer）的密钥。以下是一个示例代码： 在这个示例中，我们创建了一个TOTP验证器实例，并通过传递secret和issuer参数来设置密钥和发行者。发行者名称会在生成的密码中显示，以提供更好的可读性。 请确保已经安装了pyotp库。你可以使用pip install pyotp命令进行安装。 此代码示例展示了如何使用pyotp库生成密码，并在输出中打印生成的密码。 希望这能帮助你成功地使用带有发行者的密钥调用Google Authenticator库并生成密码。 totp验证器的issuer的作用TOTP（时间同步一次性密码）验证器的发行者（issuer）是可选的信息，用于提供更好的用户识别和区分不同应用程序或服务的标识。它通常在生成的验证码中以文本形式显示。 发行者名称可以帮助用户在Google Authenticator等身份验证应用程序中更轻松地识别和管理各种账户。当用户同时使用多个TOTP验证器时，发行者名称可以使他们更容易辨认每个账户所属的应用或服务。 例如，假设你有一个名为”MyApp”的应用程序，并为其生成了一个TOTP密钥。如果你没有指定发行者名称，那么在Google Authenticator应用程序中，你将只看到一个由6位数字组成的验证码。但是，如果你在创建TOTP验证器时指定了发行者为”MyApp”，则在Google Authenticator中，该账户将以”MyApp”开头，例如”MyApp: 123456”，这样你就能更容易地识别该密码与哪个应用相关联。 发行者名称在密码生成过程中并不影响安全性。它仅作为标识符的一部分，以增加用户识别和管理的便利性。如果你不需要发行者名称，可以省略它，而只使用密钥生成密码。 总而言之，发行者名称是可选的元数据，用于在生成的TOTP密码中提供更好的标识和用户体验，以便用户能够更轻松地区分不同应用程序或服务的身份验证账户。"},{"title":"【大模型问答】C++实现网络数据包的抓取？-GPT3.5","date":"2023-03-28T07:31:36.000Z","url":"/subweb/blog/2023/03/28/0005.C++%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E6%8A%93%E5%8F%96/","tags":[["GPT","/subweb/blog/tags/GPT/"],["网络","/subweb/blog/tags/%E7%BD%91%E7%BB%9C/"],["C++","/subweb/blog/tags/C/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"以下是一个使用C++编写的简单程序，用于抓取网络数据包： 这个程序使用了 pcap 库来进行网络数据包的抓取。首先，它打开了一个网络设备，然后可以设置过滤器来选择特定类型或端口的数据包进行捕获。在 packetHandler 函数中，可以处理抓到的每个数据包。这里只是简单地输出一条消息，你可以根据自己的需求对数据包进行相应的处理。 请注意，由于需要访问网络设备，因此执行此程序可能需要管理员权限。还要确保已安装 libpcap 库和相应的开发包。具体的编译和运行方式可能会有所不同，具体取决于你所使用的操作系统和编译环境。"},{"title":"【大模型问答】为什么CISC指令集在多方面不如RISC，却仍被广泛使用？-GPT3.5","date":"2023-03-27T07:31:36.000Z","url":"/subweb/blog/2023/03/27/0004.%E4%B8%BA%E4%BB%80%E4%B9%88CISC%E6%8C%87%E4%BB%A4%E9%9B%86%E5%9C%A8%E5%A4%9A%E6%96%B9%E9%9D%A2%E4%B8%8D%E5%A6%82RISC%EF%BC%8C%E5%8D%B4%E4%BB%8D%E8%A2%AB%E5%B9%BF%E6%B3%9B%E4%BD%BF%E7%94%A8/","tags":[["GPT","/subweb/blog/tags/GPT/"],["指令集","/subweb/blog/tags/%E6%8C%87%E4%BB%A4%E9%9B%86/"],["处理器架构","/subweb/blog/tags/%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"CISC（复杂指令集计算机）和RISC（精简指令集计算机）是两种不同的指令集架构。尽管CISC在多方面不如RISC，但它仍然被广泛使用有以下几个原因： 兼容性：CISC架构的普及源于早期计算机系统的设计，许多旧的软件和系统仍然依赖于CISC架构。为了兼容这些传统系统和软件，现代计算机仍然支持CISC指令集。 多功能性：CISC指令集具有丰富的操作码，可以执行一条指令完成复杂的操作。这使得编程人员可以用更少的指令来实现复杂的任务，从而提高编程的效率。 芯片空间利用率：由于CISC指令可以完成更多的操作，相对于RISC，执行同样的任务所需的指令数量较少。这意味着CISC处理器可以用较少的芯片空间来存储指令集，并且可以在单个指令周期内执行更多的操作。 硬件优化：CISC指令集中的某些指令可以直接在硬件级别上执行，从而减少了对软件的依赖，提高了执行效率。这种硬件优化对一些特定的应用场景非常有利。 尽管RISC架构在某些方面有优势，如更简化的指令集、更高的执行效率和更易于设计的处理器等，但CISC仍然被广泛使用是由于上述原因。实际上，许多现代处理器采用了混合的CISC和RISC特性，以兼顾各种需求。"},{"title":"【大模型问答】IPV4早就用完了，为什么我们现在上网还能分到公网可访问的公网IP？-GPT3.5","date":"2023-03-26T07:31:36.000Z","url":"/subweb/blog/2023/03/26/0003.IPV4%E6%97%A9%E5%B0%B1%E7%94%A8%E5%AE%8C%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E4%B8%8A%E7%BD%91%E8%BF%98%E8%83%BD%E5%88%86%E5%88%B0%E5%85%AC%E7%BD%91%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E5%85%AC%E7%BD%91IP/","tags":[["GPT","/subweb/blog/tags/GPT/"],["网络","/subweb/blog/tags/%E7%BD%91%E7%BB%9C/"],["IP","/subweb/blog/tags/IP/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"实际上，IPv4地址空间是有限的，且已经基本用完。然而，我们仍然能够访问公网可访问的公网IP地址的原因如下： 地址分配策略：IPv4地址池按照国家和地区进行分配，由互联网注册机构（RIRs）负责进行地址分配。这些机构根据实际需求和规则分配地址，确保更加有效地利用有限的地址资源。 网络地址转换（NAT）：NAT是一种技术，将私有IP地址转换为公共IP地址或者多个私有地址映射到一个公共地址。这样做可以通过在网络边界上的路由器或防火墙上执行地址转换，使得多个设备共享一个公网IP地址，从而缓解了IPv4地址紧缺的问题。 IPv6的部署：由于IPv4地址紧缺的问题，IPv6被开发出来以解决此问题。IPv6使用128位地址空间，提供了大量的IP地址，足够满足未来的需求。逐渐地，互联网服务供应商（ISPs）和网络运营商开始支持IPv6，并向用户提供IPv6地址，以扩展互联网的寻址能力。 尽管目前我们还在使用IPv4，但采取上述措施，我们仍然能够获得公网可访问的公网IP地址。不过，随着IPv6的普及和逐渐取代IPv4的过程，我们将能够更好地解决地址资源短缺的问题。"},{"title":"【大模型问答】世界上第一个操作系统使用机器语言写的么？-GPT3.5","date":"2023-03-25T07:31:36.000Z","url":"/subweb/blog/2023/03/25/0002.%E4%B8%96%E7%95%8C%E4%B8%8A%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E5%86%99%E7%9A%84%E4%B9%88%EF%BC%9F/","tags":[["GPT","/subweb/blog/tags/GPT/"],["机器语言","/subweb/blog/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/"],["计算机历史","/subweb/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%86%E5%8F%B2/"],["操作系统","/subweb/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"不，世界上第一个操作系统并不是使用机器语言编写的。在早期计算机发展的阶段，用于控制计算机硬件和管理资源的软件是以机器语言的形式编写的，这种语言直接与计算机的底层硬件进行交互。然而，第一个被广泛认可的操作系统——UNIVAC I操作系统（也称为最早的商业操作系统）并不是使用机器语言编写的。 UNIVAC I操作系统于1951年发布，它是在汇编语言中编写的。尽管汇编语言比机器语言更高级，但仍需要直接操作硬件指令。后来，随着技术的进步，出现了更高级的编程语言，如FORTRAN和COBOL，这些语言使得操作系统的开发变得更加高效和易于理解。因此，尽管最早的操作系统使用较低级别的语言编写，但它们并非纯粹的机器语言。"},{"title":"【大模型问答】如何使用openMVG的函数式接口生成点云？-GPT3.5","date":"2023-03-24T07:31:36.000Z","url":"/subweb/blog/2023/03/24/0001.%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8openMVG%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%94%9F%E6%88%90%E7%82%B9%E4%BA%91/","tags":[["GPT","/subweb/blog/tags/GPT/"],["三维重建","/subweb/blog/tags/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"],["openMVG","/subweb/blog/tags/openMVG/"]],"categories":[["问答留档","/subweb/blog/categories/%E9%97%AE%E7%AD%94%E7%95%99%E6%A1%A3/"]],"content":"要使用OpenMVG的函数式接口生成点云，需要按照以下步骤操作： 导入OpenMVG库并包含头文件： 加载图像和特征： 使用函数式接口生成点云： 这样就可以使用OpenMVG的函数式接口生成点云了。需要注意的是，这只是一个简单的示例代码，实际应用中需要根据具体情况进行调整和优化。"}]